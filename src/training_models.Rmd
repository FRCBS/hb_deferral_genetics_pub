---
title: "Model training"
author: "Krista Karttunen"
date: "`r Sys.time()`"
output:
  html_document:
    toc: true
    theme: united
---

```{r setup, include=TRUE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)

library(tidyverse)
library(GGally)
library(detectseparation)  # This is better than the above package
library(brms)
library(tidybayes)
library(bayesplot)
library(posterior)
library(survival)
library(survminer)
library(ggfortify)
library(ggridges)
library(gridExtra)
library(tictoc)
library(knitr)
library(kableExtra)
library(skimr)
library(patchwork)
library(ggh4x) # For more flexible facet_grid2
library(purrr)
library(broom)
library(glue)
library(ggforce)
library(tableone)
library(UpSetR)
library(scales)
library(ggcorrplot)
library(tools)
library(htmltools)
library(webshot)
library(webshot2)
library(RColorBrewer)
library(gt)
library(magick)

recompute_datas <- FALSE
recompute_cox <- FALSE
recompute_linearity_check <- FALSE
recompute_spline_models <- FALSE

recompute <- FALSE
save_figs <- TRUE
# UNCOMMENT for whole data (change the paths for WHOLE DATA run)
base <- "../training_models/training_with_snp1_group" #"../training_models/training_without_data_split"
data_path <- "../../DATA/data_preprocessed_3_20250120" #"../../DATA/training_without_data_split"
fig_path <- sprintf("%s/figures", base)
table_path <- sprintf("%s/tables", base)
source("common.R")

myscale <- function(v) { return((v - mean(v, na.rm = TRUE)) / sd(v, na.rm = TRUE))}
```

This document is used for further preprocess data for specific models and training 
multivariable logistic regression and survival models for Hb deferral. 

Codes are modified from:
https://github.com/FRCBS/anemia_and_hb_deferral_prediction/blob/main/src/deferral_logistic_and_cox.Rmd
https://github.com/FRCBS/anemia_and_hb_deferral_prediction/blob/main/src/anemia_logistic_and_cox.Rmd
https://github.com/FRCBS/anemia_and_hb_deferral_prediction/blob/main/src/create_anemia_and_deferral_article_results.Rmd


**THE CODES NEED TO BE MODIFIED DEBENDING ON IF DATA SPLIT IS DESIRED OR NOT!**
**COMMENT and UNCOMMENT notes provided to make the changes for the whole data run.**
**Search 'COMMENT for WHOLE DATA' to find them.**
**REMEBER TO CHANGE THE PATH NAMES!**

<span style="color:red; font-weight:bold">THE CODES NEED TO BE MODIFIED DEBENDING ON IF DATA SPLIT IS DESIRED OR NOT!</span>
<span style="color:red; font-weight:bold">COMMENT and UNCOMMENT notes provided to make the changes for the whole data run.</span>
<span style="color:red; font-weight:bold">Search 'COMMENT for WHOLE DATA' to find them.</span>
<span style="color:red; font-weight:bold">REMEBER TO CHANGE THE PATH NAMES!</span>

# 1. Get preprocessed data, preprocess further and examine it

## 1.1. Loading data preprocessed with summarise_data.Rmd

**WE WILL USE THE TRAIN DATA SET FOR THE MODELLING!**

<u>**Preprocessed donations data:**</u>

- Donations events for people with genotype information
- No duplicate rows
- Donation events with Hb NA are removed
- Only one donation event per day per person
- There are NA values in the variables
  + first donation event of the data set: no days to previous FB, previous Hb = 0
  + many donations are missing variable 'hour'
  + gene dosage set to NA if it's not clearly 0, 1 or 2 (see summarise_data.Rmd for details)
  + some people are missing some other variables
  
```{r Loading preprocessed donation data}
file <- ("../../DATA/data_preprocessed_2/preprocessed_donations.rdata")
load(file)

# Add "female" (boolean) variable
preprocessed_donations <- preprocessed_donations %>%
  mutate(female = sex == "female") #%>%
  #select(-sex)
```

After data investigation in this file there was a need to restrict the data:
Start: Finngen started returning genotyping info for Blood Service Biobank (01.11.2017)
End: register change in the Finnish Red Cross Blood Service (30.04.2020)

```{r Rescticting data to 11/2017 - 4/2020}
# PICKING only donation events from 01.11.2017 to 29.04.2020
old_n <- length(unique(preprocessed_donations$donor_id))

preprocessed_donations <- preprocessed_donations %>%
  filter(donation_date > "2017-10-31") %>%
  filter(donation_date < "2020-04-30")

new_n <- length(unique(preprocessed_donations$donor_id))

cat("Dropping", {old_n-new_n}, "donors due restricting time window of the donation events.\n\n")

summary(preprocessed_donations$donation_date)

```

## 1.2. Recoding SNP dosages 

There are multiple SNPs which don't have enough donors in cases and controls for all three dosages.
This will cause problems during modelling.

We have decided that for a model (all, male, female) there 
needs to be at least ten (10) donors in both the cases and controls that we will take the snp into that groups model formula.

If possible we will recode dosages 2 to 1 to be able to have enough donors for the modelling.

To be able to train the models (problems in the data set TRAIN) we need to recode the following snp 2 --> 1:

1. snp_1_113834946
2. snp_1_169549811
3. snp_4_25970243
4. snp_6_25857692
5. snp_6_68206710
6. snp_7_75844637
7. snp_15_45099877
8. snp_17_58358769
9. snp_22_29795932

(4. snp_6_23835557) Not enough what ever we do!

There is also five snps in our TRAIN data that have more dosage 2 than dosage 0. 
We will flip these dosages to make the dosage 0 the major allele and dosage 2 
the minor allele like the other snps.

1. snp_1_113834946
2. snp_7_75844637 
3. snp_9_133271182
4. snp_15_45099877
5. snp_22_37066896

**Recoding and flipping is done for the whole preprocessed data so that all data sets derived from it will have** 
**the same modifications done.**

```{r List of recoded snps}

recoded_snps <- c("snp_1_113834946", "snp_1_169549811", "snp_4_25970243", #"snp_6_23835557",
                  "snp_6_25857692", "snp_6_68206710", 
                  "snp_7_75844637", "snp_15_45099877",
                  "snp_17_58358769", "snp_22_29795932")
flipped_snps <- c("snp_1_113834946", "snp_7_75844637", "snp_9_133271182", "snp_15_45099877", "snp_22_37066896")

```

```{r The number of donors per snps dosage 2 in preprocessed donations}

for (snp in recoded_snps) {
  count <- preprocessed_donations %>%
    filter(!is.na(.data[[snp]]), .data[[snp]] == 2) %>%
    distinct(donor_id) %>%
    nrow()
  print(glue("The number of individuals in preprocessed_donations with dosage 2 in {snp} is: {count}"))
}

```

```{r Recode snp dodages}

preprocessed_donations_recoded_snps <- preprocessed_donations %>%
  mutate(snp_1_113834946 = 2-snp_1_113834946, # These snps seems to have its major and minor alleles in wrong way
         snp_7_75844637 = 2-snp_7_75844637,
         snp_9_133271182 = 2-snp_9_133271182,
         snp_15_45099877 = 2-snp_15_45099877,
         snp_22_37066896 = 2-snp_22_37066896) %>%
  mutate(across(all_of(recoded_snps), ~ case_when(. == 2 ~ 1, TRUE ~ .)))

```

```{r Save/load data_regression with recoded snp dosages}
# UNCOMMENT to save the restricted and SNP recoded data
#save(preprocessed_donations_recoded_snps, file = "../../DATA/data_preprocessed_3_20250120/preprocessed_donations_recoded_snps_2017-2020.rdata")

# UNCOMMENT if not wanting do restricting or recoding SNPs again
# The name of the rdata will be preprocessed_donations_recoded_snps
#load("../../DATA/data_preprocessed_3_20250120/preprocessed_donations_recoded_snps_2017-2020.rdata")
```

## 1.3. Create data sets for regression and cox

### 1.3.1. Define regression variables

```{r Define model variables for regression models}

snp_variables <- snp_descript$Variable
interactions <- c("smoking:female", "group:snp_22_37066896", "snp_1_169549811:group")

# Model variables for regression models
regression_variables <- c("previous_Hb", #"nb_donat", # Do we need this? We don't have it at the moment.
               "smoking", "age", "blood_volume", #weight,
               "year", "warm_season", #"hour", 
               "days_to_previous_fb", "recent_donations", "recent_deferrals", 
               #"consecutive_deferrals",  # Is 0 for everyone, causes NaN values after scaling. Were too similar to other variables. And now?
               #"previous_Hb_def", # is FALSE for the whole regression train data, can't use in the models
               snp_variables)

regression_model_variables <- c("Hb_deferral", regression_variables, "female")

```


### 1.3.2. Data for regression models

**Table were one row per donor: the first deferral event (that is not the first event in the donation data) OR** 
**the last donation event if there is no deferrals.**

```{r Unfiltered data for the regression}
# UNCOMMENT if want to model first deferral
# Data frame where donors have one row: first deferral or if no deferrals last donation event
# unfiltered_data_regression <- preprocessed_donations %>%
#   arrange(donation_date) %>%
#   filter(first_event == FALSE) %>%
#   group_by(donor_id) %>%
#   filter(Hb_deferral == 1 | row_number() == n()) %>%
#   slice(1) %>%
#   ungroup()

# THIS CODE DIDN'T DO WHAT I WANTED!
# Data frame where donors have one row: last deferral or if no deferrals last donation event
# unfiltered_data_regression <- preprocessed_donations %>%
#   arrange(donation_date) %>%
#   filter(first_event == FALSE) %>%
#   group_by(donor_id) %>%
#   filter(Hb_deferral == 1 | row_number() == n()) %>%
#   slice_tail(n=1) %>%
#   ungroup()

# Data frame where donors have one row: last deferral or if no deferrals last donation event
filename <- sprintf("%s/unfiltered_data_regression.rds", data_path)

if (recompute_datas | !file.exists(filename)) {
  old_n <- length(unique(preprocessed_donations_recoded_snps$donor_id))
  
  unfiltered_data_regression <- preprocessed_donations_recoded_snps %>%
  arrange(donation_date) %>%
  filter(first_event == FALSE) %>% # filtering out persons first events in our data set (NOT HISTORICAL DATA AVAILABLE!)
  group_by(donor_id) %>%
  mutate(has_Hb_deferral = any(Hb_deferral == 1)) %>%
  filter((has_Hb_deferral & Hb_deferral == 1) | (!has_Hb_deferral & row_number() == n())) %>%
  slice_tail(n = 1) %>%
  ungroup()
  
  new_n <- length(unique(unfiltered_data_regression$donor_id))
  
  cat("Dropping", {old_n - new_n}, "donors due to filtering first events out. \n\n")
  
  # Saving data
  saveRDS(unfiltered_data_regression, filename)
} else {
  unfiltered_data_regression <- readRDS(filename)
  cat("Loaded preprocessed unfiltred_data_regression.")
}

```


**Does the code pick the right events for the donors?**

```{r Check if the code picks the right events for donor_ids}

# Selecting the first 20 people in the unfiltered_data_regression
# first_20_donors_in_unfiltered <- unfiltered_data_regression[1:20,]

# Collecting all their events and checking manually if the right event is chosen
# records_in_preprocessed_donations <- preprocessed_donations_recoded_snps %>% 
#   filter(first_event == FALSE) %>%
#   arrange(donation_date) %>%
#   filter(donor_id %in% first_20_donors_in_unfiltered$donor_id) %>%
#   group_by(donor_id)

```

**YES! The code does pick the right event for donors: last deferral or last donation, if no deferrals.**

```{r  Plotting combinations of missing data in unfiltered regression data, fig.height=15, fig.width=12}

# Creating data for tyhe upset plot
unfiltered_data_regression_upset_data <- unfiltered_data_regression %>%
  mutate(
    dob = as.integer(!is.na(`dob`)),
    across(-dob, ~ !is.na(.))
  ) %>%
  select(donor_id, dob,
         # -hour,
         everything())

# Adjust the sets parameter to include all relevant columns
sets <- colnames(unfiltered_data_regression_upset_data)[-1]  # Exclude donor_id

# Create the upset plot
unfiltered_data_regression_upset_plot <- upset(as.data.frame(unfiltered_data_regression_upset_data),
      sets = sets,
      order.by = "freq",
      keep.order = TRUE,
      set_size.show = FALSE,
      text.scale = c(2, 1, 1, 1, 1, 1))

# Save upset plot
filename <- sprintf("%s/data_regression_upset.png", fig_path)
if (save_figs | !file.exists(filename)) {
  png(filename, width = 2400, height = 1800)  # Adjusted size
  print(unfiltered_data_regression_upset_plot)
  dev.off()
}

unfiltered_data_regression_upset_plot 

```

```{r Filter NA values out}

# Print the regression variables for which the NA filtering will be done
cat(sprintf("Model variables are %s\n\n", paste(regression_model_variables, collapse=", ")))

filename <- sprintf("%s/data_regression.rds", data_path)

if (recompute_datas | !file.exists(filename)) {
  
  # Collect the exclusions in to data frame
  exclusions_deferral_regression <- unfiltered_data_regression %>% 
    summarise(across({{regression_model_variables}}, ~ sum(is.na(.))))
  
  # Save the exclusions
  filename <- sprintf("%s/exclusions_deferral_regression.tsv", data_path)
  write_tsv(exclusions_deferral_regression, filename)
  
  old_n <- nrow(unfiltered_data_regression)
  
  # Filter NA values from all regression model variables
  data_regression <- unfiltered_data_regression %>% drop_na({{regression_model_variables}})
  
  cat(sprintf("Dropping %i/%i rows due to NA in regression model variables.\n\n", 
              old_n - nrow(data_regression), old_n))
  
  # Save the filtered data
  filename <- sprintf("%s/data_regression.rds", data_path)
  saveRDS(data_regression, filename)
} else {
  
  # Load existing data_regression
  data_regression <- readRDS(filename)
  cat("Loaded preprocessed data_regression.")
}

```

```{r Prevalence for full regression data}

group_options <- c("all", "male", "female", "pre_menopausal_female", "post_menopausal_female")

# Helper function for the prevalence calculations
# takes data frame 'df' containing donation information and
# group name as 'group_opt'.
prevalence_helper <- function(df, group_opt) {
  stopifnot(group_opt %in% group_options)
  
  # Create table containing only donors in group_opt group
  if (group_opt == "female") {
    df <- df %>% filter(group %in% c("pre_menopausal_female", "post_menopausal_female"))
  } else if (group_opt != "all") {
    df <- df %>% filter(group == group_opt)
  }
  
  # Calculate prevalence
  n <- nrow(df)
  cases <- sum(df$Hb_deferral)
  controls <- n - cases
  prevalence <- 100 * cases / n
  
  # Create tibble table from the values
  tibble(group = group_opt, n = n, cases = cases, controls = controls, `prevalence (%)` = prevalence)
}

stats <- expand_grid(group=group_options)
stats_regression <- stats %>% pmap_dfr(function(group) prevalence_helper(data_regression, group))
print(stats_regression, n=Inf)

# Save prevalence table
filename <- sprintf("%s/prevalence_data_regression.tsv", table_path)
write_tsv(stats_regression, filename)
```

#### How about picking the last donation events?

The year is significant in the regression models, which is due to the difference between the case and control
years. How about if we consider just the last events in the data set? How does it affect the year values?

```{r Plotting years from unfiltered data regression}
# UNCOMMENT if the codes creating unfiltered_data-regression not run before
# unfiltered_data_regression <- readRDS(sprintf("%s/unfiltered_data_regression.rds", data_path))

unfiltered_data_regression %>% ggplot(aes(year, fill=sex)) +
  ggh4x::facet_grid2(cols=vars(status), scales = "free", independent = TRUE) +
  geom_histogram(position="identity", alpha=0.8) +
  scale_x_continuous(breaks=waiver()) +
  scale_y_continuous(labels = label_number()) +
  scale_fill_manual(values = cohort_colors) +
  labs(title = "Donation years in unfiltered_data_regression")

```

```{r Unfiltered last donations}

#Data frame where donors have one row: the event in the data set
unfiltered_last_donations <- preprocessed_donations_recoded_snps %>%
  arrange(donation_date) %>%
  filter(first_event == FALSE) %>%
  group_by(donor_id) %>%
  slice_tail(n=1) %>%
  ungroup()

# Save the data
filename <- sprintf("%s/unfiltered_last_donations.rds", data_path)
saveRDS(unfiltered_last_donations, filename)

# Plotting the years from unfiltered_last_donations to compare with the one
# created from the data creation rule above
unfiltered_last_donations %>% ggplot(aes(year, fill=sex)) +
  ggh4x::facet_grid2(cols=vars(status), scales = "free", independent = TRUE) +
  geom_histogram(position="identity", alpha=0.8) +
  scale_x_continuous(breaks=waiver()) +
  scale_y_continuous(labels = label_number()) +
  scale_fill_manual(values = cohort_colors) +
  labs(title = "Donation years in unfiltered_last_donations")

```

This doesn't solve the issue properly either and there is far less deferral cases
if we pick only the last donation events.

```{r Create data_last_donations (regression data)}
filename <- sprintf("%s/data_last_donations.rds", data_path)
cat(sprintf("Model variables are %s\n\n", paste(regression_model_variables, collapse=", ")))

if (recompute_datas | !file.exists(filename)) {

  exclusions_last_donations <- unfiltered_last_donations %>% 
    summarise(across({{regression_model_variables}}, ~ sum(is.na(.))))
  
  filename <- sprintf("%s/exclusions_last_donations.tsv", data_path)
  write_tsv(exclusions_deferral_regression, filename)
  
  old_n <- nrow(unfiltered_last_donations)
  last_donations <- unfiltered_last_donations %>% drop_na({{regression_model_variables}})
  
  cat(sprintf("Dropping %i/%i rows due to NA in regression model variables.\n\n", 
              old_n - nrow(data_regression), old_n))
  
  filename <- sprintf("%s/data_last_donations.rds", data_path)
  saveRDS(last_donations, filename)
} else {
  last_donations <- readRDS(filename)
  cat("Loaded preprocessed last_donations.")
}
```


#### Regression data before 2020-04-30 (CRM transition)

Regression models are having really high AUC and AUPR values.
We are suspicious about the results. Cox results seem to be more what we expect.

The year has a large effect size in the models. After 30.04.2020 deferrals hasn't 
been marked into the donations data, but in another what we haven't taken into a
count. We are removing all donation events after 30.04.2020 to check if that makes any
difference to the effect sizes and AUC and AUPR values.

```{r Removing donation events after 2020-04-30}

# unfiltered_before_CRM <- preprocessed_donations_recoded_snps %>%
#   arrange(donation_date) %>%
#   filter(donation_date < "2020-04-30") %>% # keeping only events before 30-04-2020
#   filter(first_event == FALSE) %>% # filtering out persons first events in our data set
#   group_by(donor_id) %>%
#   mutate(has_Hb_deferral = any(Hb_deferral == 1)) %>%
#   filter((has_Hb_deferral & Hb_deferral == 1) | (!has_Hb_deferral & row_number() == n())) %>%
#   slice_tail(n = 1) %>%
#   ungroup()

```

```{r Filtering NAs from reg_before_CRM}

# cat(sprintf("Model variables are %s\n\n", paste(regression_model_variables, collapse=", ")))
# 
# exclusions_before_CRM <- unfiltered_before_CRM %>% 
#   summarise(across({{regression_model_variables}}, ~ sum(is.na(.))))
# 
# filename <- sprintf("%s/exclusions_before_CRM.tsv", data_path)
# write_tsv(exclusions_before_CRM, filename)
# 
# old_n <- nrow(unfiltered_before_CRM)
# data_reg_before_CRM <- unfiltered_before_CRM %>% drop_na({{regression_model_variables}})
# 
# cat(sprintf("Dropping %i/%i rows due to NA in regression model variables.\n\n", 
#             old_n - nrow(data_reg_before_CRM), old_n))
# 
# filename <- sprintf("%s/data_reg_before_CRM.rds", data_path)
# saveRDS(data_reg_before_CRM, filename)

```

```{r Splitting data_reg_before_CRM}
# data_reg_before_CRM <- split_set3(data_reg_before_CRM, seed = 42, donor_field = "donor_id")
# 
# reg_before_CRM_train <-data_reg_before_CRM %>% filter(label == "train")
# reg_before_CRM_validate <- data_reg_before_CRM %>% filter(label == "validate")
# reg_before_CRM_test <- data_reg_before_CRM %>% filter(label == "test")
# 
# print(glue("There ere {nrow(reg_before_CRM_train)} donors in the train data set."))
# print(glue("There ere {nrow(reg_before_CRM_validate)} donors in the validate data set."))
# print(glue("There ere {nrow(reg_before_CRM_test)} donors in the test data set."))
# 
# save(reg_before_CRM_train, file = sprintf("%s/data_reg_before_CRM_train.rdata", data_path))
# save(reg_before_CRM_validate, file = sprintf("%s/data_reg_before_CRM_validate.rdata", data_path))
# save(reg_before_CRM_test, file = sprintf("%s/data_reg_before_CRM_test.rdata", data_path))
```


### 1.3.3. Define Cox variables

```{r Define cox model variables}
# Model variables for cox model
cox_model_variables <- c("blood_volume",
                         "previous_Hb",
                         "smoking",
                         snp_descript$Variable,
                         "female",
                         "age", 
                         "cox_status")
```

### 1.3.4. Data for Cox model

```{r Form data for cox model part 1}

# Function helping to get the first deferral or last donation (aka censored) 
# for the donor 'key'
helper <- function(df, key) {
  df2 <- df %>% filter(Hb_deferral)
  
  if (nrow(df2) > 0) {
    # Deferral
    return(tibble(cox_status=1, donation_date=first(df2$donation_date), age_at_first_attempt = min(df$age)))
  } else {
    # Censored
    return(tibble(cox_status=0, donation_date=last(df$donation_date), age_at_first_attempt = min(df$age)))
  }
}

#recompute_cox <- TRUE
cox_filename <- sprintf("%s/prep_data_cox.rds", data_path)
if (recompute_datas | !file.exists(cox_filename)) {
  old_n <- length(unique(preprocessed_donations_recoded_snps$donor_id))
  
  prep_data_cox <- preprocessed_donations_recoded_snps %>%
    filter(first_event == FALSE) %>% # filtering out persons first event in our data set (NOT HISTORICAL DATA AVAILABLE!)
    arrange(donation_date) %>%
    group_by(donor_id) %>%
    #partition(cluster) %>%
    group_modify(helper) %>%
    ungroup()
    #collect()
  
  new_n <- length(unique(prep_data_cox$donor_id))
  
  cat("Dropping", {old_n - new_n}, "donors due to filtering first events out. \n\n")
  
  saveRDS(prep_data_cox, cox_filename)
} else {
  
  # Load existing prep_data_cox
  prep_data_cox <- readRDS(cox_filename) %>% ungroup()
  cat("Loaded precomputed prep_data_cox.")
}
```

```{r}
# Test to chack what does the filtering and join functions do
# head(data_cox %>% select(-donor_id))
# head(data_all %>% inner_join(data_cox, by = c("donor_id", "donation_date")) %>% select(-donor_id)) #%>%
#        #select(donation_date, donation_date, status, surv_status, age_at_first_attempt))
```

```{r Form data for cox model part 2}

filename <- sprintf("%s/full_cox_data.rds", data_path)
if (recompute_datas | !file.exists(filename)) {
  
  data_cox <- preprocessed_donations_recoded_snps %>% 
    filter(first_event == FALSE) %>%  # filtering out donors first event in our data set
    # this inner join lead to the data having the first event for donors with deferral and
    # last event for the ones without deferrals
    inner_join(prep_data_cox, by=c("donor_id", "donation_date")) %>%
    mutate(across(where(is.logical), as.factor))
  
  cat(sprintf("Model variables are %s\n\n", paste(cox_model_variables, collapse=", ")))
  
  # Collect and save exclusions data
  exclusions_deferral_cox <- data_cox %>% summarise(across({{cox_model_variables}}, ~ sum(is.na(.))))
  filename2 <- sprintf("%s/exclusions_deferral_cox.tsv", table_path)
  write_tsv(exclusions_deferral_cox, filename2)
  
  old_n <- nrow(data_cox); old_count2 <- ndonor(data_cox)
  
  # Filter the NA values from the cox_model_variables
  data_cox <- data_cox %>% drop_na({{cox_model_variables}})
  cat(sprintf("Dropping %i/%i rows (%i/%i donors) due to NA in cox model variables.\n\n", 
              old_n - nrow(data_cox), old_n, old_count2 - ndonor(data_cox), old_count2))
  
  # Save filtered
  saveRDS(data_cox, filename)
} else {
  
  # Load existeing data_cox
  cat("Loaded precomputed data_cox.")
  data_cox <- readRDS(filename)
}
```

```{r Prevalence of full cox data}
tmp <- data_cox %>% mutate(across(where(is.factor), as.logical)) # needs logical for sum()
stats <- expand_grid(group=group_options)
stats_cox <- stats %>% pmap_dfr(function(group) prevalence_helper(tmp, group))
print(stats_cox, n=Inf)

# Save the prevalence table
filename <- sprintf("%s/prevalence_data_cox.tsv", table_path)
write_tsv(stats_cox, filename)
```

```{r Print summary of cox data cencoring}
cat("Stats for full cox data: \n")
cat(sprintf("%i donors, %i events, %i censored \n", nrow(data_cox), sum(data_cox$cox_status == 1), 
            sum(data_cox$cox_status == 0)))
cat(sprintf("Prevalence of Hb-deferral: %.1f%%", 100*sum(data_cox$cox_status == 1) / nrow(data_cox)))
```

## 1.4. Split regression and cox data to train, test and validate data sets (inc. prevalence tables)

Regression data will model the last Hb_deferral, but survival models model the first Hb_deferral.
So we find the common donors only by matching the donor_ids in regression and cox data.

After finding the common donors we label them with train, test and validate. 
Modelling will be done only with the train labelled donors.
This makes sure that we have as similar data for the methods as can be.

Data for time-dependent cox model is different from the regression and cox data sets 
and contains multiple rows for a person. This data set will be created for the train labelled
individuals that are common in the other two data sets.

### 1.4.1. Common donors in regression and cox data sets

```{r Common donors in data_regression and data_cox}
common_donors <- data_regression %>%
  inner_join(data_cox, by = "donor_id") %>%
  select(donor_id) %>%
  distinct()

cat("There are", {nrow(common_donors)}, "common donor_ids in regression and cox data sets. \n")
cat("There are", {length(setdiff(data_regression$donor_id, common_donors$donor_id))}, "that are only in the data_regression.\n")
cat("There are", {length(setdiff(data_cox$donor_id, common_donors$donor_id))}, "that are only in the data_cox.\n")
```

The different deferrals are picked for the data sets:
- data_regression has the LAST deferral
- data_cox has the FIRST deferral

```{r The differences between the two data sets}

data_regression_and_cox <- data_regression %>% 
  filter(donor_id %in% common_donors$donor_id) %>%
  inner_join(data_cox %>% 
               filter(donor_id %in% common_donors$donor_id), by = "donor_id", suffix = c(".reg", ".sur"))

# Checking how many have differing donation_dates
diff_donation_date <- data_regression_and_cox %>%
  filter(donation_date.reg != donation_date.sur) %>%
  select(donor_id, donation_date.reg, donation_date.sur, Hb_deferral.reg, Hb_deferral.sur, age.reg, age.sur,
         previous_Hb.reg, previous_Hb.sur) #%>%
  #nrow()

cat("There are", nrow(diff_donation_date), 
    " donors that have differing donation dates in the regression and cox data sets",
    "due to the different Hb_deferral picked by the models.")

# This is a test code
# tmp <- preprocessed_donations %>% 
#   filter(donor_id %in% diff_donation_date$donor_id) %>% 
#   group_by(donor_id) %>%
#   arrange(donation_date) %>%
#   ungroup() %>%
#   arrange(donor_id) %>%
#   select(donor_id, first_event, donation_date, status)

```

```{r Function to add labels for donors}

# Add label values for donors

tvt_ratios <- c(train = 0.64, validate = 0.16, test = 0.20)

# Can be used to split data set to train, validate, and test parts in given fraction.
# Adds column 'label' which is either a string 'train', 'validate', or 'test'
split_set3 <- function(df, seed, prob = tvt_ratios, donor_field = "donor_id") {
  message("In function split_set3")
  set.seed(seed)
  donors <- unique(df[[donor_field]])
  n <- length(donors)
  if (FALSE) {
    labels <- sample(factor(c("train", "validate", "test"), levels = c("train", "validate", "test")),
                     size = n, replace = TRUE, prob = prob)
  } else {
    n1 <- as.integer(prob[1] * n)
    n2 <- as.integer(prob[2] * n)
    n3 <- n - n1 - n2
    labels <- c(rep("train", n1), rep("validate", n2), rep("test", n3))
    labels <- factor(sample(labels, size = n), levels=c("train", "validate", "test"))  # permute
  }
  classes <- tibble({{donor_field}} := donors,
                    label=labels)
  return(inner_join(df, classes))
}
```

```{r Label common donors}

common_donors <- split_set3(common_donors, seed = 42, donor_field = "donor_id")

```

### 1.4.2. Split regression data

```{r Split regression data to train, validate and test sets}
#recompute_datas <- TRUE

if (recompute_datas) {
  cat("Resplitting data_regression. \n\n")
  
  data_regression <- data_regression %>%
    filter(donor_id %in% common_donors$donor_id) %>%  # filter out donors that are not in the common donors
    inner_join(common_donors, by = "donor_id")    # add labels for donors
  
  # Create the different data sets
  regression_train <- data_regression %>% filter(label == "train")
  regression_validate <- data_regression %>% filter(label == "validate")
  regression_test <- data_regression %>% filter(label == "test")

  print(glue("There ere {nrow(regression_train)} donors in the train data set for the regression models."))
  print(glue("There ere {nrow(regression_validate)} donors in the validate data set for the regression models."))
  print(glue("There ere {nrow(regression_test)} donors in the test data set for the regression models."))
  
  # Save the split data sets
  save(regression_train, file = sprintf("%s/data_regression_train.rdata", data_path))
  save(regression_validate, file = sprintf("%s/data_regression_validate.rdata", data_path))
  save(regression_test, file = sprintf("%s/data_regression_test.rdata", data_path))
} else {
  # Load existing splitted data sets
  load(sprintf("%s/data_regression_train.rdata", data_path))
  cat("Loaded presplit regression_train. \n")

  load(sprintf("%s/data_regression_validate.rdata", data_path))
  cat("Loaded presplit regression_validate. \n")

  load(sprintf("%s/data_regression_test.rdata", data_path))
  cat("Loaded presplit regression_test. \n")
}

```

```{r Setting whole regression data into regression_train}
# UNCOMMENT for WHOLE DATA
# regression_train <- data_regression
```

#### Prevalence tables for regression data sets

```{r Prevalence table for regression_train}
stats <- expand_grid(group=group_options)
stats_reg_train <- stats %>% pmap_dfr(function(group) prevalence_helper(regression_train, group))
print(stats_reg_train, n=Inf)

filename <- sprintf("%s/prevalence_regression_train.tsv", table_path)
write_tsv(stats_reg_train, filename)
```

```{r Prevalence table for regression_test}
# UNCOMMENT to produce and save prevalence table
# stats <- expand_grid(group=group_options)
# stats_reg_test<- stats %>% pmap_dfr(function(group) prevalence_helper(regression_test, group))
# print(stats_reg_test, n=Inf)
# 
# filename <- sprintf("%s/prevalence_regression_test.tsv", table_path)
# write_tsv(stats_reg_test, filename)
```

```{r Prevalence table for regression_validate}
# UNCOMMENT to produce and save prevalence table
# stats <- expand_grid(group=group_options)
# stats_reg_validate<- stats %>% pmap_dfr(function(group) prevalence_helper(regression_validate, group))
# print(stats_reg_validate, n=Inf)
# 
# filename <- sprintf("%s/prevalence_regression_validate.tsv", table_path)
# write_tsv(stats_reg_validate, filename)
```

### 1.4.3 Split cox data

```{r Split cox data to train, validate and test sets}

if (recompute_datas) {
  
  cat("Resplitting data_cox. \n\n")

  data_cox <- data_cox %>% 
    mutate(female = as.logical(female)) %>%
    filter(donor_id %in% common_donors$donor_id) %>% # filter out donors that are not in the common donors
    inner_join(common_donors, by = "donor_id")       # add labels for donors
  
  # Create the data sets
  cox_train <- data_cox %>% filter(label == "train")
  cox_validate <- data_cox %>% filter(label == "validate")
  cox_test <- data_cox %>% filter(label == "test")
  
  print(glue("There are {nrow(cox_train)} donors in the train data set for the cox model."))
  print(glue("There are {nrow(cox_validate)} donors in the validate data set for the cox model."))
  print(glue("There are {nrow(cox_test)} donors in the test data set for the cox model."))
  
  # Save data sets
  save(cox_train, file = sprintf("%s/data_cox_train.rdata", data_path))
  save(cox_validate, file = sprintf("%s/data_cox_validate.rdata", data_path))
  save(cox_test, file = sprintf("%s/data_cox_test.rdata", data_path))
} else {
  # Load existing splitted data sets
  load(sprintf("%s/data_cox_train.rdata", data_path))
  cat("Loaded presplit cox_train. \n")

  load(sprintf("%s/data_cox_validate.rdata", data_path))
  cat("Loaded presplit cox_validate. \n")

  load(sprintf("%s/data_cox_test.rdata", data_path))
  cat("Loaded presplit cox_test. \n")
}

```

```{r Setting whole cox data into the cox_train}
# UNCOMMENT for WHOLE DATA
# cox_train <- cox_data
```

#### Prevalence tables for cox data sets

**HOX! These stats should be the same as regression data sets!**

```{r Prevalence table for cox_train}
tmp <- cox_train %>% mutate(across(where(is.factor), as.logical)) # needs logical for sum()
stats <- expand_grid(group=group_options)
stats_cox_train <- stats %>% pmap_dfr(function(group) prevalence_helper(tmp, group))
# print(stats_cox_train, n=Inf)

filename <- sprintf("%s/prevalence_cox_train.tsv", table_path)
write_tsv(stats_cox_train, filename)

helper <- function(sur, group) {
  cat(sprintf("Group %s: %i donors, %i events, %i censored, prevalence %.1f%%\n", 
              group,
              nrow(sur), 
              sum(sur$cox_status == 1), 
              sum(sur$cox_status == 0),
              100*sum(sur$cox_status == 1) / nrow(sur)))
  
}

cat("Stats for cox train data: \n")
helper(cox_train, "all")
helper(cox_train %>% filter(sex == "male"), "male")
helper(cox_train %>% filter(sex == "female"), "female")

```

```{r Prevalence table for cox_test}
# UNCOMMENT to produce and save the prevalence table
# tmp <- cox_test %>% mutate(across(where(is.factor), as.logical)) # needs logical for sum()
# stats <- expand_grid(group=group_options)
# stats_cox_test <- stats %>% pmap_dfr(function(group) prevalence_helper(tmp, group))
# # print(stats_cox_test, n=Inf)
# 
# filename <- sprintf("%s/prevalence_cox_test.tsv", table_path)
# write_tsv(stats_cox_test, filename)
# 
# cat("Stats for cox test data: \n")
# helper(cox_test, "all")
# helper(cox_test %>% filter(sex == "male"), "male")
# helper(cox_test %>% filter(sex == "female"), "female")

```

```{r Prevalence table for cox_validate}
# UNCOMMENT to produce and save the prevalence table
# tmp <- cox_validate %>% mutate(across(where(is.factor), as.logical)) # needs logical for sum()
# stats <- expand_grid(group=group_options)
# stats_cox_validate <- stats %>% pmap_dfr(function(group) prevalence_helper(tmp, group))
# # print(stats_cox_validate, n=Inf)
# 
# filename <- sprintf("%s/prevalence_cox_validate.tsv", table_path)
# write_tsv(stats_cox_validate, filename)
# 
# cat("Stats for cox validate data: \n")
# helper(cox_validate, "all")
# helper(cox_validate %>% filter(sex == "male"), "male")
# helper(cox_validate %>% filter(sex == "female"), "female")
# 
# # cat(sprintf("%i donors, %i events, %i censored \n", nrow(cox_validate), sum(cox_validate$cox_status == 1), 
# #             sum(cox_validate$cox_status == 0)))
# # cat(sprintf("Prevalence of Hb-deferral: %.1f%%", 100*sum(cox_validate$cox_status == 1) / nrow(cox_validate)))
```


## 1.5. Data for cox with time-dependent covariates

Here is a vignette used as guide to generate the correct survival data for time dependent 
cox analysis: https://cran.r-project.org/web/packages/survival/vignettes/timedep.pdf

```{r Define model variabled for tdc}
# Model variables for tdc cox model
baseline_variables <- c("blood_volume",
                        "smoking",
                        snp_descript$Variable,
                        "female")

tdc_variables <- c("previous_Hb")  # time-dependent covariates

tdc_model_variables <- c(baseline_variables, tdc_variables)
```

```{r Create data for cox modelling with time-dependent variables}
# Function to cut time-series at the first deferral. 
# Number of donors stays the same
until_first_deferral <- function(df) {
  has_deferrals <- df %>% group_by(donor_id) %>% filter(max(Hb_deferral)==1) %>% ungroup()
  has_no_deferrals <- df %>% group_by(donor_id) %>% filter(max(Hb_deferral)==0) %>% ungroup()
  has_deferrals <- has_deferrals %>% 
    arrange(donation_date) %>% 
    group_by(donor_id) %>% 
    slice(1:min(which(Hb_deferral))) %>% 
    ungroup()
  result <- bind_rows(has_no_deferrals, has_deferrals)
  return(result %>% arrange(donation_date))
}

# COMMENT for WHOLE DATA
filename <- sprintf("%s/tdc2_data_train.rds", data_path)

# UNCOMMENT for WHOLE DATA
#filename <- sprintf("%s/tdc2_data.rds", data_path)

if(recompute_datas | !file.exists(filename)) {
  
  # Collect donor IDs with the label 'train'
  common_donors_train <- common_donors %>% filter(label == "train")
  
  # All donation events for the common_donors(_train)
  don <- preprocessed_donations_recoded_snps %>% 
    #filter(first_event == FALSE) %>%           # filtering out persons first event in our data set
    # COMMENT for WHOLE DATA
    filter(donor_id %in% common_donors_train$donor_id)  # for only common donors that have train label
    # UNCOMMENT for WHOLE DATA
    #filter(donor_id %in% common_donors$donor_id)  # for only common donors in reg & cox; without data split
  
  don <- until_first_deferral(don)

  baseline <- preprocessed_donations_recoded_snps %>%
    #filter(first_event == FALSE) %>%               # filtering out persons first event in our data set
    # COMMENT for WHOLE DATA
    filter(donor_id %in% common_donors_train$donor_id)  # for only common donors that have train label
    # UNCOMMENT for WHOLE DATA
    #filter(donor_id %in% common_donors$donor_id)  # for only common donors in reg & cox; without data split
    mutate(across(where(is.logical), as.factor)) %>% 
    select(all_of(c("donor_id", baseline_variables))) %>%
    distinct()
  
  # Collect and save exclusions
  exclusions_tdc <- baseline %>% summarise(across({{baseline_variables}}, ~ sum(is.na(.))))
  filename2 <- sprintf("%s/exclusions_tdc.tsv", table_path)
  write_tsv(exclusions_tdc, filename2)
  
  old_n <- nrow(baseline); old_count2 <- ndonor(baseline)
  baseline <- baseline %>% drop_na({{baseline_variables}})
  cat(sprintf("Dropping %i/%i rows (%i/%i donors) due to NA in tdc model variables.", 
              old_n - nrow(baseline), old_n, old_count2 - ndonor(baseline), old_count2))
  
  # Common donors in the baseline and don data frames
  common_dons <- intersect(unique(baseline$donor_id), unique(don$donor_id))
  
  # Filter baseline and don tables to include only common_dons
  baseline <- baseline %>% filter(donor_id %in% common_dons)
  don <- don %>% filter(donor_id %in% common_dons)
  
  # Start the data creation with tmerge() function
  data_tdc <- tmerge(data1=baseline, 
                data2=don %>% group_by(donor_id) %>% slice_tail(n=1) %>% ungroup(),  # Last donations
                id=donor_id, tstop=age, tdc_status = event(age, Hb_deferral))
  
  data_tdc2 <- tmerge(data1=data_tdc, 
                 data2=don,
                 id=donor_id, 
                 donation_count=cumtdc(age, !Hb_deferral, 0),
                 previous_Hb=tdc(age, Hb))
  
  # Save finnished data set
  saveRDS(data_tdc2, filename)
} else {
  # Load existing data
  data_tdc2 <- readRDS(filename)
  cat("Loaded precombiled data_tdc2 (train).")
  
  # UNCOMMENT for WHOLE DATA
  #cat("Loaded precombiled data_tdc2.")
}
```

**Does the created data look sensible?**

See the Value section in the help page of `survival::tmerge` for explanation of the columns.

```{r Summary of data for cox modelling with time-dependent variables}
summary(data_tdc2)
```

Looks fine.

### Prevalence

```{r Prevalence for tdc data}
helper <- function(data, group) {
  tmp <- data %>% drop_na() %>% arrange(tstop) %>% group_by(donor_id) %>% slice_tail(n=1)
  
  cat(sprintf("Time-dependent covariate Cox, group %s: %i donors, %i events, %i censored, prevalence %.1f%%\n", 
            group,
            nrow(tmp), 
            sum(tmp$tdc_status == 1), 
            sum(tmp$tdc_status == 0),
            100*sum(tmp$tdc_status == 1) / nrow(tmp)))
}

helper(data_tdc2, "all")
helper(data_tdc2 %>% filter(female == FALSE), "male")
helper(data_tdc2 %>% filter(female == TRUE), "female")
```

**Why is there a difference between the number of unique donor_ids in the data_tdc2 and the of** 
**donors taken into the prevalence!?!**

```{r Checking the difference in the number of donors}
tmp1 <- data_tdc2 %>% arrange(tstop) %>% group_by(donor_id) %>% slice_tail(n=1)
tmp <- data_tdc2 %>% drop_na() %>% arrange(tstop) %>% group_by(donor_id) %>% slice_tail(n=1)
cat(sprintf("Donors in the data_tcd2: %s vs. Donors after drop_na() %s. The difference is: %s \n\n", 
              nrow(tmp1), nrow(tmp), nrow(tmp1)-nrow(tmp)))

# collect the dropped donors into a table
donors_dropped <- data_tdc2 %>% 
  arrange(tstop) %>% 
  group_by(donor_id) %>% 
  slice_tail(n=1) %>% 
  filter(is.na(previous_Hb)) %>% 
  select(donor_id, tstart, tstop, tdc_status, donation_count, previous_Hb)

# calculate donations counts per donor
donation_counts <- preprocessed_donations_recoded_snps %>%
  group_by(donor_id) %>%
  summarise(don_count = n())

# calculate deferral counts per donor
deferral_counts <- preprocessed_donations_recoded_snps %>%
  group_by(donor_id) %>%
  filter(Hb_deferral == TRUE) %>%
  summarise(def_count = n())

# add donation and deferral counts of the dropped donors
donors_dropped <- donors_dropped %>%
  left_join(donation_counts, by = "donor_id") %>%
  left_join(deferral_counts, by = "donor_id") %>%
  mutate(don_count = ifelse(is.na(don_count), 0, don_count),
         def_count = ifelse(is.na(def_count), 0, def_count))

summary(donors_dropped)
```

**Before 03.12.2024:** The drop_na() is removing 1562 donors who have NA for the previous_Hb. These people have only one row
in the data_tdc2. (this was when the filter first events was active in the tcd2 data set creation)

When the filtering for the first events during the tdc2 data creation is removed there are 605 
donors dropped away.

**Data restricted to 1.11.2017-29.4.2020:** 3780 dropped.

**How many donation events do they have in the preprocessed_donations_recoded_snp data set?**
**For the 1562 donors:** 
- 758 donors who have tdc_status TRUE, have the second donation in preprocessed data set (first event not counted)
a deferral. So for these people there is no further donation events taken into the data_tdc2.
- 804 donors who have tdc_status FALSE, have only two donation events in the preprocessed data set.

**For 605 donors:**
- all have tdc_status TRUE, donation_count = 0 and thus previous_Hb NA.
- all donors have had deferral at their first donation event.
- many have donated successfully after that(see summary(dropped_donors))

Is there something wrong in the creation of data_tdc2? Does this affect the modelling?
I think the code for creations of data_tcd2 works as it should. Is the filtering of the first_events
neccessary though? Could this fix the problem?
- The problem is not completely solved. 605 donors are still removed due to their
first donation event in our data being deferral.

**Does this affect the modelling?** 
I don't think so. The NA is the default for the tmerge() if there is no first value given.

**Should I remove these people from the regression_train and cox_train data sets?**
- I'm not sure. But if we want the model data sets to be as identical as they can then yes?
- Let's keep the additional donors in the regression and cox. There just needs to be the 
same donors and not different from the regression and cox data sets. So if there are not 
all the donors from the regression and cox, that is just the case here, because the data 
creation is done the way it is.


## 1.6. Figures to examine (train) data sets

### 1.6.1. Table 1. for the regression and cox

```{r Setting all up for Table 1. & the plots}

# Variables not included in the models should be removed
variables_to_drop <- c("Hb_first", "previous_Hb_def", "consecutive_deferrals", 
                       "first_event", "dob")

# let's start with these snps HOX! SNPs in chromosomes 6 and 15 has little bit different position
# old_snps <- c("snp_1_169549811","snp_6_32618190","snp_15_45099877","snp_17_58358769")

categorical_variables <- c("smoking", "warm_season") #, snp_variables)
continuous_variables <- c("age", "year", #"hour", 
                          "Hb", "previous_Hb", "days_to_previous_fb",
                          "recent_donations", "recent_deferrals", "weight", "blood_volume")

all_variables <- c(categorical_variables, continuous_variables)

my_vars <- c(
  "Age",
  "Smoking",
  #"Weight (kg)",
  "Blood volume",
  "Year",
  #"Hour",
  "Warm season",
  "Hemoglobin",
  "Previous Hb",
  "Days to previous full blood donation",
  "Donations in last two years",
  "Deferrals in last two years",
  snp_descript$Pretty
)

non_normal_vars <- c("Smoking", "Year", #"Hour", 
                     "Warm season",
                     "Days to previous full blood donation",
                     "Donations in last two years",
                     "Deferrals in last two years",
                     snp_descript$Pretty
                     )

```

```{r Table 1. for regression data train - all included}
# Create the data needed for the table 1 creation
table1data <- regression_train %>% select(-any_of(variables_to_drop)) %>%
  mutate(sex = factor(sex, levels = c("male", "female"))) %>%  # to ensure the male comes before female
  pretty_col_names(descript)

# Calculate the total number of people in each group
n_all <- nrow(table1data)
n_male <- nrow(table1data %>% filter(Sex == "male"))
n_female <- nrow(table1data %>% filter(Sex == "female"))

# Create summary tables for each group
summary_table_all <- CreateTableOne(data = table1data,
                                    vars = my_vars,
                                    strata = c("status"),
                                    factorVars = c("Smoking", snp_descript$Pretty),
                                    test = FALSE)

summary_table_mf <- CreateTableOne(data = table1data,
                                    vars = my_vars,
                                    strata = c("status", "Sex"),
                                    factorVars = c("Smoking", snp_descript$Pretty),
                                    test = FALSE)

# Print the summary tables
tab_all <- print(summary_table_all,
                 nonnormal = non_normal_vars,
                 vars = my_vars,
                 quote = FALSE,
                 noSpaces = TRUE,
                 printToggle = FALSE)

tab_mf <- print(summary_table_mf,
                 nonnormal = non_normal_vars,
                 vars = my_vars,
                 quote = FALSE,
                 noSpaces = TRUE,
                 printToggle = FALSE)

# Combine the tables
tab_combined <- cbind(tab_all, tab_mf)

write.table(tab_combined,
            file = paste0(table_path, "/table_1_regression_train.tsv"), sep = "/t")

# Remove the original column names
colnames(tab_combined) <- rep("", ncol(tab_combined))

# Define the column headers
header <- c(" ", "All" = 2, "Male" = 2, "Female" = 2)
sub_header <- c(" ", "Case", "Control", "Case", "Control", "Case", "Control")

# Convert the table to HTML format and add hierarchical column headers
html_table <- kable(tab_combined, format = "html", table.attr = "class='table table-striped'",
                    caption = sprintf("Regression train - Table 1. %s", Sys.Date())) %>%
  add_header_above(sub_header, bold = TRUE, align = "center") %>%
  add_header_above(header, bold = TRUE, align = "center") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Print the HTML table
html_table

#Save the table as html and pdf
html_file <- sprintf("%s/table_1_regression_train.html", table_path)
save_kable(html_table, file = html_file)
webshot(html_file, file = sprintf("%s/table_1_regression_train.pdf", table_path))
```

```{r Table 1. for cox train - all included}
# Create the data needed for the table 1 creation
table1data <- cox_train %>% select(-any_of(variables_to_drop)) %>%
  mutate(sex = factor(sex, levels = c("male", "female"))) %>% # to ensure the male comes before female
  pretty_col_names(descript)

# Calculate the total number of people in each group
n_all <- nrow(table1data)
n_male <- nrow(table1data %>% filter(Sex == "male"))
n_female <- nrow(table1data %>% filter(Sex == "female"))

# Create summary tables for each group
summary_table_all <- CreateTableOne(data = table1data,
                                    vars = my_vars,
                                    strata = c("status"),
                                    factorVars = c("Smoking", snp_descript$Pretty),
                                    test = FALSE)

summary_table_mf <- CreateTableOne(data = table1data,
                                    vars = my_vars,
                                    strata = c("status", "Sex"),
                                    factorVars = c("Smoking", snp_descript$Pretty),
                                    test = FALSE)

# Print the summary tables
tab_all <- print(summary_table_all,
                 nonnormal = non_normal_vars,
                 vars = my_vars,
                 quote = FALSE,
                 noSpaces = TRUE,
                 printToggle = FALSE)

tab_mf <- print(summary_table_mf,
                 nonnormal = non_normal_vars,
                 vars = my_vars,
                 quote = FALSE,
                 noSpaces = TRUE,
                 printToggle = FALSE)

# Combine the tables
tab_combined <- cbind(tab_all, tab_mf)

write.table(tab_combined,
            file = paste0(table_path, "/table_1_cox_train.tsv"), sep = "/t")

# Remove the original column names
colnames(tab_combined) <- rep("", ncol(tab_combined))

# Define the column headers
header <- c(" ", "All" = 2, "Male" = 2, "Female" = 2)
sub_header <- c(" ", "Case", "Control", "Case", "Control", "Case", "Control")

# Convert the table to HTML format and add hierarchical column headers
html_table <- kable(tab_combined, format = "html", table.attr = "class='table table-striped'",
                    caption = sprintf("Cox train - Table 1. %s", Sys.Date())) %>%
  add_header_above(sub_header, bold = TRUE, align = "center") %>%
  add_header_above(header, bold = TRUE, align = "center") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

# Print the HTML table
html_table

#Save the table as html and pdf
html_file <- sprintf("%s/table_1_cox_train.html", table_path)
save_kable(html_table, file = html_file)
webshot(html_file, file = sprintf("%s/table_1_cox_train.pdf", table_path))
```


Normally distributed variable are summarized as mean (SD), non-normally distributed variable are summarized as median (25th, 75th percentile)

<span style="color:red; font-weight:bold">There are slight differences between the regression and cox Table 1. values for age, warm season, hemoglobin, previous HB and days to</span>
<span style="color:red; font-weight:bold">previous full blood donation. This is due to the difference in the deferral event selected (first vs. last).</span>

### 1.6.2. Variable histograms

```{r Variable histograms - categorical & continuous - regression_train}

# Change the grouping variable according to the need
grouping_variable <- "sex" #"group"

# Categorical variables
g1 <- double_summary_plotter_case_control(regression_train %>% 
                                            select(c("status", grouping_variable), all_of(categorical_variables)) %>% 
                                            drop_na(), 
                                          descript, grouping_variable = grouping_variable, geom="bar", ncol=4) + 
  theme_gray(base_size = 9) +
  theme(legend.position="right",
        legend.direction = "vertical",
        strip.text.x = element_text(size = 6),
        strip.text.y.right = element_text(angle = 0)
        ) +
  # COMMENT for WHOLE DATA
  labs(title = "Regression train - Categorical variables")
  # UNCOMMENT for WHOLE DATA
  # labs(title = "Whole Regression data - Categorical variables")

# Continuous variables
g2 <- double_summary_plotter_case_control(regression_train %>% 
                                            select(c("status", grouping_variable), all_of(continuous_variables)) %>% 
                                            drop_na(), 
                                          descript, grouping_variable = grouping_variable, geom="histogram", ncol=4) + 
  theme_gray(base_size = 9) +
  theme(legend.position="right",
        legend.direction = "vertical",
        strip.text.x = element_text(size = 6),
        strip.text.y.right = element_text(angle = 0)
        ) +
  # COMMENT for WHOLE DATA
  labs(title = "Regression train - Continuous variables")
  # UNCOMMENT for WHOLE DATA
  # labs(title = "Whole Regression data - Continuous variables")

gg1 <- g1 + scale_x_discrete(limit = factor(0:1))
  
scales2 <- unify_range_by_rows(g2)
gg2 <- g2 + ggh4x::facetted_pos_scales(scales2)


if (save_figs) {
  # COMMENT for WHOLE DATA
  ggsave(paste(fig_path, sprintf("regression_train_deferral_histogram_case_control_categorical_%s.png", 
                               grouping_variable), sep = "/"), gg1, width = 180, units = "mm", dpi = 300)
  ggsave(paste(fig_path, sprintf("regression_train_deferral_histogram_case_control_categorical_%s.pdf",
                                 grouping_variable), sep = "/"), gg1, width = 180, units = "mm")
  
  ggsave(paste(fig_path, sprintf("regression_train_deferral_histogram_case_control_continuous_%s.png", 
                               grouping_variable), sep = "/"), gg2, width = 180, units = "mm", dpi = 300)
  ggsave(paste(fig_path, sprintf("regression_train_deferral_histogram_case_control_continuous_%s.pdf",
                                 grouping_variable), sep = "/"), gg2, width = 180, units = "mm")
  
  # UNCOMMENT for WHOLE DATA
  # ggsave(paste(fig_path, sprintf("whole_regression_deferral_histogram_case_control_categorical_%s.pdf", 
  #                                grouping_variable), sep = "/"), gg1, width = 180, units = "mm")
  # ggsave(paste(fig_path, sprintf("whole_regression_deferral_histogram_case_control_continuous_%s.pdf", 
  #                                grouping_variable), sep = "/"), gg2, width = 180, units = "mm")
}

gg1
gg2

```

```{r Variable histograms - categorical & continuous - cox_train}
# Change according to the wishes
# grouping_variable <- "sex" # "group"

# TEST CODES
# in the cox_train the logical values has been made factorial, but this was a problem for the plotting function
# tmp <- cox_train %>% 
#   mutate(female = as.logical(female),
#          warm_season = as.logical(warm_season),
#          first_event = as.logical(first_event),
#          Hb_deferral = as.logical(Hb_deferral),
#          previous_Hb_def = as.logical(previous_Hb_def),
#          smoking = as.logical(smoking),
#          one_deferral = as.logical(smoking))

# This is needed to be able to plot the warm_season variable
cox_train <- cox_train %>% mutate(warm_season = as.logical(as.character(warm_season)))

# Categorical variables
g1 <- double_summary_plotter_case_control(cox_train %>% 
                                            select(c("status", grouping_variable), all_of(categorical_variables)) %>% 
                                            drop_na(), 
                                          descript, grouping_variable = grouping_variable, geom="bar", ncol=4) + 
  theme_gray(base_size = 9) +
  theme(legend.position="right",
        legend.direction = "vertical",
        strip.text.x = element_text(size = 6),
        strip.text.y.right = element_text(angle = 0)
        ) +
  # COMMENT for WHOLE DATA
  labs(title = "Cox train - Categorical variables")
  # UNCOMMENT for WHOLE DATA
  #labs(title = "Whole Cox data - Categorical variables")

# Continuous variables
g2 <- double_summary_plotter_case_control(cox_train %>% 
                                            select(c("status", grouping_variable), all_of(continuous_variables)) %>% 
                                            drop_na(), 
                                          descript, grouping_variable = grouping_variable, geom="histogram", ncol=4) + 
  theme_gray(base_size = 9) +
  theme(legend.position="right",
        legend.direction = "vertical",
        strip.text.x = element_text(size = 6),
        strip.text.y.right = element_text(angle = 0)
        ) +
  # COMMENT for WHOLE DATA
  labs(title = "Cox train - Continuous variables")
  # UNCOMMENT for WHOLE DATA
  # labs(title = "Whole Cox data - Continuous variables")

gg1 <- g1 + scale_x_discrete(limit = factor(0:1))
  
scales2 <- unify_range_by_rows(g2)
gg2 <- g2 + ggh4x::facetted_pos_scales(scales2)

if (save_figs) {
  # COMMENT for WHOLE DATA
  ggsave(paste(fig_path, sprintf("cox_train_deferral_histogram_case_control_categorical_%s.pdf", 
                                 grouping_variable), sep = "/"), gg1, width = 180, units = "mm")
  ggsave(paste(fig_path, sprintf("cox_train_deferral_histogram_case_control_continuous_%s.pdf", 
                                 grouping_variable), sep = "/"), gg2, width = 180, units = "mm")
  
  # UNCOMMENT for WHOLE DATA
  # ggsave(paste(fig_path, sprintf("whole_cox_deferral_histogram_case_control_categorical_%s.pdf",
  #                                grouping_variable), sep = "/"), gg1, width = 180, units = "mm")
  # ggsave(paste(fig_path, sprintf("whole_cox_deferral_histogram_case_control_continuous_%s.pdf",
  #                                grouping_variable), sep = "/"), gg2, width = 180, units = "mm")
}

gg1
gg2

```

**Because there is such a difference between smoking status in males and females,**
**we need to add interaction between smoking and sex into the model containing both groups.**

<br>

**There is no difference in the snp counts between regression and cox data sets** 
**because the people in them are the same.**

```{r For extracting the SNP dosages before recoding}
# UNCOMMENT for getting the unrecoded SNPs for plotting purposes after recoding
# unrecoded_dosages <- regression_train %>%
#   select(donor_id, status, sex, group) %>%
#   left_join(preprocessed_donations %>% select(donor_id, starts_with("snp_")), by = "donor_id") %>%
#   distinct()

```

```{r Variable histograms - snps}

# 24 snp_variables and I want 6 plots per page
plots_per_page <- 7
total_plots <- length(snp_variables)
total_pages <- ceiling(total_plots / plots_per_page)
# grouping_variable <- "group" # "sex"

for (i in 1:total_pages) {
  start_idx <- (i - 1) * plots_per_page + 1
  end_idx <- min(i * plots_per_page, total_plots)
  current_snp_vars <- snp_variables[start_idx:end_idx]

  g3 <- double_summary_plotter_case_control(regression_train %>% # Change unrecoded_dosages for checking the unrecoded SNPs
                                              select(c("status", grouping_variable), all_of(current_snp_vars)) %>% 
                                              drop_na(), 
                                            descript, grouping_variable = grouping_variable, geom="bar", ncol=3) + 
    theme_gray(base_size = 9) +
    theme(legend.position="right",
          legend.direction = "vertical",
          strip.text.x = element_text(size = 6),
          strip.text.y.right = element_text(angle = 0)
          ) +
    # COMMENT for WHOLE DATA
    labs(x = "dosage", title = sprintf("Train - SNP variables %d/%d", i, total_pages))
    # UNCOMMENT for WHOLE DATA
    #labs(x = "dosage", title = sprintf("Whole data - SNP variables %d/%d", i, total_pages))
  
  gg3 <- g3 + scale_x_discrete(limit = factor(0:2))
  
  # COMMENT for WHOLE DATA
  filename <- sprintf("/train_histogram_case_control_snps_page_%d.pdf", i)
  
  # UNCOMMENT for WHOLE DATA
  #filename <- sprintf("/whole_data_histogram_case_control_snps_page_%d.pdf", i)
  
  # UNCOMMENT for unrecoded snps
  #filename <- sprintf("/UR_train_histogram_case_control_snps_page_%d.pdf", i)
  
  ggsave(paste0(fig_path, filename),
         gg3, width = 180, height = 200, units = "mm")
  print(gg3)
}
```

```{r Combine snps histogram pdfs, message=FALSE, warning=FALSE}

# Combine the SNP PDFs
# COMMENT for WHOLE DATA
pdf_files <- paste0(fig_path, sprintf("/train_histogram_case_control_snps_page_%d.pdf", 1:total_pages))
combined_pdf <- paste0(fig_path, sprintf("/train_histogram_case_control_snps_combined_%s.pdf",
                                                    grouping_variable))

# UNCOMMENT for WHOLE DATA
# pdf_files <- pdf_files <- paste0(fig_path, sprintf("/whole_data_histogram_case_control_snps_page_%d.pdf", 1:total_pages))
# combined_pdf <- paste0(fig_path, sprintf("/whole_data_histogram_case_control_snps_combined_%s.pdf",
#                                                    grouping_variable))

# UNCOMMENT for unrecoded SNPs
# pdf_files <- pdf_files <- paste0(fig_path, sprintf("/UR_train_histogram_case_control_snps_page_%d.pdf", 1:total_pages))
# combined_pdf <- paste0(fig_path, sprintf("/UR_train_histogram_case_control_snps_combined_%s.pdf",
#                                                     grouping_variable))

qpdf::pdf_combine(input = pdf_files,
                  output = combined_pdf)


```

**Why is there such a large difference between the snp dosages for this and train data before?!?**
- Code didn't do what I wanted it to do...

```{r Examining snp dosage differences, include=FALSE}
# load("../../DATA/data_preprocessed_2/data_regression_first_def_last_control/data_regression_train.rdata")
# train1 <- train
# 
# load("../../DATA/data_preprocessed_2/data_regression_train.rdata")
# train2 <- train
# 
# identical_rows <- train1 %>%
#   inner_join(train2, by = names(train1))
# 
# snp_counts1 <- train1 %>%
#   select(starts_with("snp_")) %>%
#   pivot_longer(cols = everything(), names_to = "snp", values_to = "value") %>%
#   count(snp, value)
# 
# # View the counts
# 
# ggplot(snp_counts1, aes(x = value, y = n, fill = snp)) +
#   geom_bar(stat = "identity", position = "dodge") +
#   labs(x = "Value", y = "Count", title = "Histogram of SNP Counts Train 1") +
#   theme_minimal()
# 
# snp_counts2 <- train2 %>%
#   select(starts_with("snp_")) %>%
#   pivot_longer(cols = everything(), names_to = "snp", values_to = "value") %>%
#   count(snp, value)
# 
# # View the counts
# 
# ggplot(snp_counts2, aes(x = value, y = n, fill = snp)) +
#   geom_bar(stat = "identity", position = "dodge") +
#   labs(x = "Value", y = "Count", title = "Histogram of SNP Counts Train 2") +
#   theme_minimal()
# 

```

### 1.6.3. Correlation matrices for regression_train data

```{r Correlation matrix - all (regression_train), fig.dim=c(10,12)}

df_all <- regression_train %>%
  mutate(sex = as.factor(sex),
         #across(starts_with("snp_"), as.factor),
         group = as.factor(group)) %>%
  select(sex, group, age, year, warm_season, #hour, 
         blood_volume, Hb, Hb_deferral, days_to_previous_fb, previous_Hb,
         recent_donations, recent_deferrals, smoking, weight, all_of(starts_with("snp_")), status)

contrasts_list <- lapply(df_all[, c("sex", "status")], 
                         contrasts, contrasts = FALSE)
  


corr <- model.matrix(~ . - 1, data = df_all, contrasts.arg = contrasts_list)

corr <- corr %>%
  cor(use = "pairwise.complete.obs") %>%
  ggcorrplot(show.diag = FALSE,
             type = "lower",
             lab = TRUE,
             lab_size = 1,
             tl.cex = 8,
             col = c("#00468B", "white", "#ED0000"),
             # COMMENT for WHOLE DATA
             title = "Correlation matrix - all (regression_train)")
             # UNCOMMENT for WHOLE DATA
             # title = "Correlation matrix - all (data_regression)")

corr

# COMMENT for WHOLE DATA
ggsave(paste(fig_path, "correlation_matrix_regression_train_all.pdf", sep="/"), corr, units="mm")

# UNCOMMENT for WHOLE DATA
# ggsave(paste(fig_path, "whole_data_correlation_matrix_regression_all.pdf", sep="/"), corr, units="mm")

```

```{r Correlation matrix - male (regression_train), fig.dim=c(10,12)}

df_all <- regression_train %>%
  filter(sex == "male") %>%
  select(age, year, warm_season, #hour, 
         blood_volume, Hb, Hb_deferral, days_to_previous_fb, previous_Hb,
         recent_donations, recent_deferrals, smoking, weight, all_of(starts_with("snp_")), status)

contrasts_list <- lapply(df_all[, c("status")], contrasts, contrasts = FALSE)


corr <- model.matrix(~ . - 1, data = df_all, contrasts.arg = contrasts_list)

corr <- corr %>%
  cor(use = "pairwise.complete.obs") %>%
  ggcorrplot(show.diag = FALSE,
             type = "lower",
             lab = TRUE,
             lab_size = 1,
             tl.cex = 8,
             col = c("#00468B", "white", "#ED0000"),
             # COMMENT for WHOLE DATA
             title = "Correlation matrix - male (regression_train)")
             # UNCOMMENT for WHOLE DATA
             # title = "Correlation matrix - male (data_regression)")

corr

# COMMENT for WHOLE DATA
ggsave(paste(fig_path, "correlation_matrix_regression_train_male.pdf", sep="/"), corr, units="mm")

# UNCOMMENT for WHOLE DATA
# ggsave(paste(fig_path, "whole_data_correlation_matrix_regression_male.pdf", sep="/"), corr, units="mm")

```

```{r Correlation matrix - female (regression_train), fig.dim=c(10,12)}

df_all <- regression_train %>%
  filter(sex == "female") %>%
  mutate(group = as.factor(group)) %>%
  select(group, age, year, warm_season, #hour, 
         blood_volume, Hb, Hb_deferral, days_to_previous_fb, previous_Hb,
         recent_donations, recent_deferrals, smoking, weight, all_of(starts_with("snp_")), status)

contrasts_list <- lapply(df_all[, c("status")], contrasts, contrasts = FALSE)
  


corr <- model.matrix(~ . - 1, data = df_all, contrasts.arg = contrasts_list)

corr <- corr %>%
  cor(use = "pairwise.complete.obs") %>%
  ggcorrplot(show.diag = FALSE,
             type = "lower",
             lab = TRUE,
             lab_size = 1,
             tl.cex = 8,
             col = c("#00468B", "white", "#ED0000"),
             # COMMENT for WHOLE DATA
             title = "Correlation matrix - female (regression_train)")
             # UNCOMMENT for WHOLE DATA
             # title = "Correlation matrix - female (data_regression)")

corr

# COMMENT for WHOLE DATA
ggsave(paste(fig_path, "correlation_matrix_regression_train_female.pdf", sep="/"), corr, units="mm")

# UNCOMMENT for WHOLE DATA
# ggsave(paste(fig_path, "whole_data_correlation_matrix_regression_female.pdf", sep="/"), corr, units="mm")
```



## 1.7. Deferrals by years in the different whole data sets

Deferral rate is know to affect the model performance when Hb deferral is modeled.
Here are codes to examine the deferral rates in the data sets by year and sex.

```{r Deferral rates in the preprocessed_donations_recoded_snps, fig.width=10}

# Calculate rate 
rate_data <- preprocessed_donations_recoded_snps %>%
  filter(Hb_deferral == TRUE) %>%
  group_by(year, sex) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  left_join(preprocessed_donations_recoded_snps %>%
              group_by(year, sex) %>%
              summarise(total = n()), by = c("year", "sex")) %>%
  mutate(rate = count/total)

# Create plot separated by year and sex
g <- ggplot(rate_data, aes(x = year, y = rate, fill = sex)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = scales::percent(round(rate, 4))),
            position = position_dodge(width = 0.9), vjust = 0.25, hjust = -0.1) +
  labs(y = "Deferral rate", fill = "Sex") +
  scale_x_continuous(breaks = seq(2000, 2024, by = 1)) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.06)) +
  scale_fill_manual(values = cohort_colors) +
  facet_grid(~sex) +
  labs(title = "Deferral rate in preporocessed_donations") +
  coord_flip()

g

# save the plot as png
filename <- sprintf("%s/deferral_yearly_rates_preprocessed_donations.png", fig_path)
ggsave(filename, plot = g, width = 20, height = 10) 

```

```{r Deferral rates in the regression data, fig.width=10}

# Calculate rates
rate_data <- data_regression %>%
  filter(Hb_deferral == TRUE) %>%
  group_by(year, sex) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  left_join(data_regression %>%
              group_by(year, sex) %>%
              summarise(total = n()), by = c("year", "sex")) %>%
  mutate(rate = count/total)

# Create plot
g <- ggplot(rate_data, aes(x = year, y = rate, fill = sex)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = scales::percent(round(rate, 4))),
            position = position_dodge(width = 0.9), vjust = 0.25, hjust = -0.1) +
  labs(y = "Deferral rate", fill = "Sex") +
  scale_x_continuous(breaks = seq(2000, 2024, by = 1)) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.5)) +
  scale_fill_manual(values = cohort_colors) +
  facet_grid(~sex) +
  labs(title = "Deferral rate in data_regression") +
  coord_flip()

g

# Save plot as png
filename <- sprintf("%s/deferral_yearly_rates_data_regression.png", fig_path)
ggsave(filename, plot = g, width = 20, height = 10) 
```

```{r Check if the rates are calculated right - reg}
# Testing
# table(data_regression %>% filter(Hb_deferral == TRUE) %>% select(year, sex))
# table(data_regression %>% filter(Hb_deferral == FALSE) %>% select(year, sex))
```

```{r Deferral rates in the whole cox data}
# Calculate rates
rate_data <- data_cox %>%
  mutate(Hb_deferral = as.logical(Hb_deferral == "TRUE")) %>%
  filter(Hb_deferral == TRUE) %>%
  group_by(year, sex) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  left_join(data_cox %>%
              group_by(year, sex) %>%
              summarise(total = n()), by = c("year", "sex")) %>%
  mutate(rate = count/total)

# Create plot
g <- ggplot(rate_data, aes(x = year, y = rate, fill = sex)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = scales::percent(round(rate, 4))),
            position = position_dodge(width = 0.9), vjust = 0.25, hjust = -0.1) +
  labs(y = "Deferral rate", fill = "Sex") +
  scale_x_continuous(breaks = seq(2000, 2024, by = 1)) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.6)) +
  scale_fill_manual(values = cohort_colors) +
  facet_grid(~sex) +
  labs(title = "Deferral rate in data_cox") +
  coord_flip()

g

# Save plots
filename <- sprintf("%s/deferral_yearly_rates_data_cox.png", fig_path)
ggsave(filename, plot = g, width = 20, height = 10) 
```

```{r Check if the rates are calculated right - cox}
# Tests
# table(data_cox %>% filter(Hb_deferral == TRUE) %>% select(year, sex))
# table(data_cox %>% filter(Hb_deferral == FALSE) %>% select(year, sex))
```

```{r Deferral rate last_donations}
# Calculate rates
rate_data <- last_donations %>%
  filter(Hb_deferral == TRUE) %>%
  group_by(year, sex) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  left_join(last_donations %>%
              group_by(year, sex) %>%
              summarise(total = n()), by = c("year", "sex")) %>%
  mutate(rate = count/total)

# create plot
g <- ggplot(rate_data, aes(x = year, y = rate, fill = sex)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = scales::percent(round(rate, 4))),
            position = position_dodge(width = 0.9), vjust = 0.25, hjust = -0.1) +
  labs(y = "Deferral rate", fill = "Sex") +
  scale_x_continuous(breaks = seq(2000, 2024, by = 1)) +
  scale_y_continuous(labels = scales::percent, limits = c(0,0.06)) +
  scale_fill_manual(values = cohort_colors) +
  facet_grid(~sex) +
  labs(title = "Deferral rate in last_donations") +
  coord_flip()

g

# Save plot
filename <- sprintf("%s/deferral_yearly_rates_last_donations.png", fig_path)
ggsave(filename, plot = g, width = 20, height = 10) 
```

```{r Check if the rates are calculated right - last don}
# Testing
# table(last_donations %>% filter(Hb_deferral == TRUE) %>% select(year, sex))
# table(last_donations %>% filter(Hb_deferral == FALSE) %>% select(year, sex))
```


## 1.8. Total genetic risk from train data

```{r The number of dosages per donor}

# Filtering dosages from train to separate table
dosages <- regression_train %>%
  select(donor_id, starts_with("snp_")) %>%
  distinct()

total <- dosages %>% rowwise(donor_id) %>% summarise(total = sum(c_across(everything())))
g <- total %>% ggplot(aes(x = total)) + geom_bar() 
g + labs(x = "Total dosage", title = "The number of dosages per donor")

```



# 2. Check snp additivity

Testing the assumption that the SNPs which have donors with 0, 1 and 2 dosages and
not just 0 and 1 can be modelled additively.

```{r List of additive SNPs}
additive_snps <- c("snp_6_32617727", "snp_6_32658525", "snp_8_10785723",
                   "snp_8_23520397", "snp_8_75503352", "snp_9_133271182",
                   "snp_10_63174788", "snp_12_6030341", "snp_14_33938877",
                   "snp_20_35186730", "snp_22_37066896")

# Function would be better option. One that selects the SNP variables with
# 0, 1 and 2 dosages.
```

```{r Check additivity function}

# Function which produces a fit for a SNP with or without covariates
check_additivity <- function(data, snp, method="glm.fit", covariates=c()) {
  data2 <- data %>%
    mutate(Hb_deferral = ifelse(Hb_deferral, "case", "control")) %>%
    mutate(Hb_deferral = as.factor(Hb_deferral)) %>%
    mutate(additive = .data[[snp]],
           deviation = as.integer(.data[[snp]]==2),
           Hb_deferral = fct_relevel(Hb_deferral, c("control", "case"))) # set control as baseline not case
  
  # Define the model formula
  s <- glue("Hb_deferral ~ additive + deviation")
  if (length(covariates) > 0) {
    s <- paste(c(s, covariates), collapse = " + ")
  }
  
  # Changing formulas class from character to formula
  f <- as.formula(s)
  
  # Fit the model
  m <- glm(f, data = data2, family = "binomial", method = method)
  m
}

```

```{r Plot_additivity_effects function}
# Function to plot the results of the fits done with check_additivity function
plot_additivity_effects <- function(additivity_effects, page) {
  g <- additivity_effects %>%
    filter(term == "deviation" | term == "additive") %>%
    mutate(term = factor(term, levels=c("deviation", "additive")),
           color = if_else(p.value < 0.05, "red", "black"),
           snp = factor(snp, levels = additive_snps)) %>%
    ggplot(aes(x=estimate, xmin=conf.low, xmax=conf.high, y=term)) + 
    geom_vline(xintercept = 1, color = "gray") +
    geom_pointrange() +
    geom_text(aes(label = sprintf("p=%.2e", p.value), color=I(color)), hjust=0.5, nudge_y = 0.25) +
    #facet_wrap(~snp, scales = "free_x", ncol = 3, nrow = 3)
    # HOX! Change the ncol and nrow according to the wishes, now there is 12 (3x4) plots per page
    facet_wrap_paginate(~snp, scales = "free_x", ncol = 3, nrow = 4, page = page) +
    labs(title = paste("Additivity test - Page ", i))
  
  g
  
  # UNCOMMENT if you want to save the plots
  # HOX! one is for the ones without covariates and for with
  # filename <- sprintf("%s/additivity_effects_%s.png", fig_path, page)
  # filename <- sprintf("%s/additivity_effects_cov_%s.png", fig_path, page)
  # ggsave(filename, plot = g, device = "png")
}
```


### 2.1. Without covariates

```{r Additivity without covariates}

tmp <- snp_variables %>% set_names() %>%
  additive_snps %>% set_names() %>%
  map(function(snp) {
    check_additivity(regression_train, snp) %>% tidy(conf.int=TRUE, exponentiate=TRUE)
  })

additivity_effects <- tmp %>% bind_rows(.id = "snp") %>% filter(term != "(Intercept)")

```

```{r Plotting additivity effects without covariates}

for (i in 1:1) {
  print(plot_additivity_effects(additivity_effects, page = i))
}

# Testing
#plot_additicity_effects(additivity_effects, page = 1)

```

```{r Save additivity plots as pdf}

filename <- sprintf("%s/additivity_effects.pdf", fig_path)
if (save_figs | !file.exists(filename)) {
  # Open a PDF device
  pdf(filename)
  
  # Loop through the pages and print the plots
  # HOX! Change the number after : for the number of pages you have
  for (i in 1:1) {
    print(plot_additivity_effects(additivity_effects, page = i))
  }
  
  # Close the PDF device
  dev.off()
}

```

None of the snp had significant non-additive model so we will stick with the additive model
for all the snps.

### 2.2. With covariates age and sex

```{r Additivty with covariates}

tmp <- snp_variables %>% set_names() %>%
  #additive_snps %>% set_names() %>%
  map(function(snp) {
    check_additivity(regression_train, snp, covariates = c("age", "sex")) %>% 
      tidy(conf.int=TRUE, exponentiate=TRUE)
  })

additivity_effects_cov <- tmp %>% bind_rows(.id = "snp") %>% filter(term != "(Intercept)")

```

```{r Plotting additivity effects with age and sex}

for (i in 1:1) {
  print(plot_additivity_effects(additivity_effects_cov, page = i))
}

# Testing
#table(additivity_effects$term)

```

```{r Save additivity covariate plots ad pdf}

filename <- sprintf("%s/additivity_effects_plots_covariates.pdf", fig_path)
if (save_figs | !file.exists(filename)) {
  # Open a PDF device
  pdf(filename)
  
  # Loop through the pages and print the plots
  # HOX! Change the number after : for the number of pages you have
  for (i in 1:1) {
    print(plot_additivity_effects(additivity_effects_cov, page = i))
  }
  
  # Close the PDF device
  dev.off()

}
```

There was no change in when adding the covariates.

# 3. Logistic regression for deferral

## 3.1. Split data into demographic groups and scale

```{r Scale data for logistic regression}
# Additional data sets tested
#load("../../DATA/data_preprocessed_2/data_regression_train.rdata")
#load("../../DATA/data_preprocessed_2/data_reg_before_CRM_train.rdata")
# regression_train <- reg_before_CRM_train

# UNCOMMENT for WHOLE DATA
# SHOULD BE DONE ALREADY IN THE 1.4. after the data split
# regression_train <- data_regression #for whole data training

# Scale the data sets
data_all <- regression_train %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_") , myscale))
data_male <- regression_train %>% 
  filter(sex == "male") %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
data_female <- regression_train %>% 
  filter(sex == "female") %>% 
  mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))

# UNCOMMENT if separate models for these demographic groups wanted
# data_pre_menopausal_female <- data_all %>% 
#   filter(group == "pre_menopausal_female") %>% 
#   mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))
# data_post_menopausal_female <- data_all %>% 
#   filter(group == "post_menopausal_female") %>% 
#   mutate(across(where(is.numeric) & ! starts_with("snp_"), myscale))

```

```{r Get normalizing constansts for each group}

stat_helper <- function(df) {
  df %>% summarise(across(where(is.numeric) & ! starts_with("snp_"), 
                          list(mean=~mean(.x, na.rm=TRUE), 
                               sd=~sd(.x, na.rm=TRUE))))
}

stat_helper2 <- function(df) { # long form version
  df %>%
    select(where(is.numeric) & ! starts_with("snp_")) %>% 
    pivot_longer(cols=everything()) %>%
    group_by(name) %>% 
    summarise(mean=mean(value, na.rm=TRUE), sd=sd(value, na.rm=TRUE))
}


dfall <- stat_helper2(regression_train)
dfm <- stat_helper2(regression_train %>% filter(group=="male"))
dffe <- stat_helper2(regression_train %>% filter(group != "male"))
# UNCOMMENT if needed
# dfpre <- stat_helper2(regression_train %>% filter(group=="pre_menopausal_female"))
# dfpost <- stat_helper2(regression_train %>% filter(group=="post_menopausal_female"))

# Combine the different tables
variable_stats <- bind_rows(all=dfall, male=dfm, female=dffe, .id="group")
rm(dfall, dfm, dffe)

# COMMENT for WHOLE DATA
filename <- sprintf("%s/regession_train_variable_stats.rds", table_path)

# UNCOMMENT for WHOLE DATA
#filename <- sprintf("%s/whole_regression_data_variable_stats.rds", table_path)

# Additional data sets tested
# filename <- sprintf("%s/reg_before_CRM_train_variable_stats.rds", table_path)
# filename <- sprintf("%s/regession_train_cox_vars_variable_stats.rds", table_path)
# filename <- sprintf("%s/regression_train_cox_vars_bcrm_variable_stats.rds", table_path)

# Save varaible stats
saveRDS(variable_stats, filename)
```

## 3.2. Logistic regression

```{r Frequentist logistic regression formulas}

# For testing purposes to find out if the difference between variables
# in regression and cox models is the reason for too good AUC and AUPR values
# regression_variables <- setdiff(regression_variables,
#                                 c("year",
#                                   "warm_season",
#                                   "recent_deferrals",
#                                   "recent_donations",
#                                   "days_to_previous_fb"))

# SNPs that needs to be removed form all the models
regression_variables <- setdiff(regression_variables,
                                c("snp_6_21989753", "snp_6_22583313", "snp_6_23835557"))


freq_formula_all <- as.formula(sprintf("Hb_deferral ~ %s", paste(c(regression_variables, "female"), 
                                                                 collapse=" + ")))
print(freq_formula_all)

freq_formula_male <- as.formula(sprintf("Hb_deferral ~ %s", paste(setdiff(regression_variables, 
                                                                          c("snp_6_68206710", "snp_11_5226799"
                                                                            #"recent_deferrals"
                                                                            )), collapse=" + ")))
print(freq_formula_male)

freq_formula_female <- as.formula(sprintf("Hb_deferral ~ %s", paste(regression_variables, collapse=" + ")))
print(freq_formula_female)

# UNCOMMENT if needed
# freq_formula_pre_menopausal_female <- as.formula(sprintf("Hb_deferral ~ %s", paste(setdiff(variables, 
#                                                                                            "snp_6_22583313"), collapse=" + ")))
# freq_formula_post_menopausal_female <- as.formula(sprintf("Hb_deferral ~ %s", paste(setdiff(variables, 
#                                                                                             c("snp_6_21989753", "snp_6_22583313", 
#                                                                                               "snp_6_23835557", "snp_7_75844637",
#                                                                                               "snp_11_5226799", "snp_15_45099877",
#                                                                                               "recent_deferrals")),
#                                                                                     collapse=" + ")))
# print(freq_formula_pre_menopausal_female)
# print(freq_formula_post_menopausal_female)

datas <-list(all=data_all, male=data_male, female=data_female)
             # UNCOMMENT if needed
             # pre_menopausal_female=data_pre_menopausal_female,
             # post_menopausal_female=data_post_menopausal_female)
freq_formulas <- list(all=freq_formula_all, male=freq_formula_male, female=freq_formula_female)
             # UNCOMMENT if needed
             # pre_menopausal_female=freq_formula_pre_menopausal_female,
             # post_menopausal_female=freq_formula_post_menopausal_female)

```

### 3.2.1. Detect separation

According to Jarkko: 'safeBinaryRegression' package sucks, I now use 'detectseparation' instead!

Krista: I will just use 'detectseparation' then.

```{r Testing detecting separation}
# Testing detecting separation
# test_formula <- "Hb_deferral ~ female + age + smoking"
# 
# test_fit <- stats::glm(test_formula,
#              data = data,
#              method="detect_separation",
#              family = "binomial")
# test_fit
```


**Detect separation: pre_menopausal_females, post_menopausal_females**
```{r}
# UNCOMMENT if needed
# fit_pre_menopausal <- stats::glm(freq_formula_pre_menopausal_female,
#                                  data = data_pre_menopausal_female,
#                                  method = "detect_separation",
#                                  family = "binomial")
# fit_pre_menopausal
# 
# fit_post_menopausal <- stats::glm(freq_formula_post_menopausal_female,
#                                  data = data_post_menopausal_female,
#                                  method = "detect_separation",
#                                  family = "binomial")
# fit_post_menopausal
```

No separation detected.

**Detect separation: females, males**

```{r}
# Detecting separation for females
fit_female <- stats::glm(freq_formula_female,
                         data = data_female,
                         method = "detect_separation",
                         family = "binomial")
fit_female

# Detecting separation for males
fit_male <- stats::glm(freq_formula_male,
                       data = data_male,
                       method = "detect_separation",
                       family = "binomial")
fit_male
```

**Females:** No separation detected.

**Males:** Separation with snp_6_21989753 and snp_6_22583313: There is not enough males in either cases or controls
when it comes to these variables. Removing them from the male model.


**Detecting separation: whole data**

```{r Detect for separation}
# Detecting separation for all donors
fit <- stats::glm(freq_formula_all,
             data = data_all,
             method="detect_separation",
             family = "binomial")
fit
```

NO separation detected for the whole data. We can fit the models.

### 3.2.2. Fit models and fit summaries
```{r Fitting freq model for separately for all donors}
filename <- sprintf("%s/fit.rds", base)

# Additional data setstested
# filename <- sprintf("%s/fit_before_CRM.rds", base)
# filename <- sprintf("%s/fit_cox_vars.rds", base)
# filename <- sprintf("%s/fit_cox_vars_before_CRM.rds", base)

if(recompute | !file.exists(filename)) {
  fit <- stats::glm(freq_formula_all,
                    data = data_all,
                    family = "binomial")
  saveRDS(fit, filename)
} else {
  cat("Loading prefitted freq model for Hb-deferral.")
  fit <- readRDS(filename)
}
```

```{r Checking if the model is modelling Hb_deferral the right way}

# If the model predicts the Hb_deferral = TRUE should the 
# mean(fit$y) be close to the prevalence of deferral in the data set used
# for model fitting
# mean(fit$y)

# mean(predict(fit, type="response") >= 0.5) 
```

```{r Summary fit}
#summary(fit)
```

```{r Fitting freq models for group datas}

fit_freq_helper <- function(group, data, formula) {
  filename <- sprintf("%s/freq_fit_%s.rds", base, group)
  
  # Additional data sets tried
  # filename <- sprintf("%s/freq_fit_before_CRM_%s.rds", base, group)
  # filename <- sprintf("%s/freq_fit_cox_vars_%s.rds", base, group)
  # filename <- sprintf("%s/freq_fit_cox_vars_before_CRM_%s.rds", base, group)
  
  if (recompute | !file.exists(filename)) {
    freq_fit <- stats::glm(formula,
                           data = data,
                           family = "binomial")
    saveRDS(freq_fit, filename)
  } else {
    cat(sprintf("Loading prefitted freq model for Hb-deferral on group %s\n", group))
    freq_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(freq_fit)))
}

freq_input <- tibble(group=setdiff(names(cohort_colors), c("pre_menopausal_female", "post_menopausal_female")),
                         data=datas,
                         formula=freq_formulas)
freq_fits <- pmap_dfr(freq_input, fit_freq_helper)
freq_fits_list <- deframe(freq_fits)
```

```{r Save freq_fits as a list}
filename <- sprintf("%s/freq_fits_list.rds", base)
saveRDS(freq_fits_list, filename)
```

```{r Summary freq_fit - all}
summary(freq_fits_list$all)
```

```{r Summary freq_fit - male}
summary(freq_fits_list$male)
```

```{r Summary freq_fit - female}
summary(freq_fits_list$female)
```

```{r Summaries freq_fit- post and pre}
# UNCOMMENT if needed
# summary(freq_fits_list$pre_menopausal_female)
# summary(freq_fits_list$post_menopausal_female)
```


### 3.2.3. Diagnostics
#### Residual deviance

Jarkko (in deferral_logistic_and_cox.Rmd):
"Residual deviance is significantly smaller than null deviance so the predictors offer significant information.
The median of deviance residuals is not very close to zero, which means there could be a small bias. The distribution of residuals should
be approximately normal: [What do the residuals in a logistic regression mean](https://stats.stackexchange.com/questions/1432/what-do-the-residuals-in-a-logistic-regression-mean)"

```{r Plot the deviance residuals}
regression_train %>% 
  mutate(residual=residuals(fit)) %>% ggplot(aes(x=residual)) + geom_histogram()
```

Jarkko:
For explanation of deviance see:

* [Interpreting Residual and Null Deviance in GLM R](https://stats.stackexchange.com/questions/108995/interpreting-residual-and-null-deviance-in-glm-r)
* [Interpreting Generalized Linear Models](https://www.datascienceblog.net/post/machine-learning/interpreting_generalized_linear_models/)


```{r Pretty logistic formula}
# This is for presentation purposes
# s <- as.character(formula(fit))
# conv <- setNames(descript$Pretty, descript$Variable)
# conv <- conv[conv != "Hemoglobin"]
# cat(sprintf("Hb deferral ~ %s", str_replace_all(s[[3]], conv)))
```

#### Default glm diagnostics

```{r Diagnostic plots for linear model}
plot(fit, which=c(1,2,3,4,5))
```

```{r Cooks distances - freq}

filename <- sprintf("%s/cooks_dictance_freq.png", fig_path)
if (save_figs) png(filename, width = 600, height = 400)
plot(fit, which = 4)
if (save_figs) dev.off()

```


Jarkko:
One should not use the above plots to interpret results of logistic regression according to 
https://stats.stackexchange.com/questions/234998/logistic-regression-diagnostic-plots-in-r

The advise on page http://www.sthda.com/english/articles/36-classification-methods-essentials/148-logistic-regression-assumptions-and-diagnostics-in-r/
is to check for

* linearity
* influential points using Cook's distance (above plot showed no influential points)
* multicollinearity using Variance inflation factors

Krista: I will follow these guidelines too.


#### Check for linearity

```{r Propabilities from the fit}
probabilities <- predict(fit, type = "response")
```

```{r Combining logit values with table data_all}
data2 <- data_all %>% 
  select(all_of(regression_variables)) %>% 
  drop_na() %>%
  select(where(is_double)) %>% 
  mutate(logit=log(probabilities/(1-probabilities)))
```

```{r Relation between each predictor with the logit scale response 1}
# Test plot
# filename <- sprintf("%s/linearity_check.png", fig_path)
# if (recompute_linearity_check | !file.exists(filename)) {
#   g <- data2 %>%
#     slice_sample(n=1000) %>% # For quick testing purposes
#     pivot_longer(cols = -logit, names_to = "predictor") %>%
#     ggplot(aes(logit, value))+
#     geom_point(size = 0.5, alpha = 0.5) +
#     geom_smooth(method = "loess") + 
#     theme_bw() + 
#     facet_wrap(~predictor, scales = "free_y")
#   ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
#   g
# } else {
#   knitr::include_graphics(filename)
# }

```

Reversing the axes makes a better plot.

```{r Testing data etc before linearity check plot}
# test <- data2 %>%
#     #head(1000) %>%
#     select(#-recent_deferrals & 
#       -year & !starts_with("snp")) %>%
#     #slice_sample(n=1000) %>% # For quick testing purposes
#     pivot_longer(cols = -logit, names_to = "predictor") %>%
#     inner_join(variable_stats %>% filter(group=="all"), by=c(predictor="name")) %>%  # Add normalizing constants
#     mutate(value = value*sd+mean) 
# 
# summary(test$value)
# summary(test$logit)
# 
# sum(is.na(test$value))
# sum(is.na(test$logit))
```

```{r Relation between each predictor with the logit scale response 2}
recompute_linearity_check <- TRUE
filename <- sprintf("%s/linearity_check.png", fig_path)
if (recompute_linearity_check | !file.exists(filename)) {
  g <- data2 %>%
    #head(1000) %>%
    select(-recent_deferrals & -year & !starts_with("snp")) %>%
    #slice_sample(n=1000) %>% # UNCOMMENT for quick testing purposes
    pivot_longer(cols = -logit, names_to = "predictor") %>%
    inner_join(variable_stats %>% filter(group=="all"), by=c(predictor="name")) %>%  # Add normalizing constants variable_stats
    mutate(value = value*sd+mean) %>%   # normalize
    ggplot(aes(x = value, y = logit)) +
    geom_point(size = 0.5, alpha = 0.5) +
    geom_smooth(method = "loess", color = "blue", se = FALSE) +
    labs(y="Log odds of Hb-deferral") +
    theme_bw() + 
    facet_wrap(~predictor, scales = "free_x")
  ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  g
} else {
  cat("Loaded precomputed linearity check.")
  knitr::include_graphics(filename)
}
```

**Are these linearities good enough?** - Looks okay to me.

#### Check for multicollinearity

```{r Check for multicollinearity - freq}
# Variance inflation factors 
freq_vifs <- t(map_dfr(freq_fits_list, function(x) as_tibble(t(car::vif(x))))) %>% 
  as_tibble(rownames = "Variable")
colnames(freq_vifs) <- c("Variable", names(freq_fits_list))
filename <- sprintf("%s/deferral_vifs.tsv", table_path)
write_tsv(freq_vifs, filename)
```

```{r Create colored table of the VIFs - freq}
# Create a gt table with colored cells
gt_table <- freq_vifs %>%
  mutate(Variable = to_pretty_vector(Variable, descript)) %>%
  gt() %>%
  tab_header(
    title = "(a) VIFs for LogR Models",
  ) %>%
  cols_label(
    Variable = "Variable"
  ) %>%
  fmt_number(
    columns = vars(-Variable),
    decimals = 2
  ) %>%
  data_color(
    columns = vars(-Variable),
    colors = scales::col_bin(
      bins = c(0, 5, Inf),
      palette = c("white", "red")
    )
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_body(columns = everything())
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_column_labels(columns = everything())
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_stub()
  )

# Save the tables as png and pdf
filename <- sprintf("%s/VIFs_freq.png", fig_path)
gtsave(gt_table, filename, vwidth = 300)

filename <- sprintf("%s/VIFs_freq.pdf", fig_path)
gtsave(gt_table, filename)

# Print the gt table
print(gt_table)
```

Jarkko: According to https://www.statisticshowto.com/variance-inflation-factor/
VIF value greater than 5 means that it is highly correlated with other predictors.

Krista: All VIF values are around 1 so no correlation between predictors.

```{r Correlations tsv and pdf - freq}
# Temporary descript 'd' where the long Pretty varaibles names are shorter
# Fit better into the table
d <- descript %>% 
  mutate(Pretty = case_when(Pretty == "Days to previous full blood donation" ~ "Days to previous fbd*",
                                            Pretty == "Deferrals in last two years" ~ "Recent deferrals",
                                            Pretty == "Donations in last two years" ~ "Recent donations",
                                            TRUE ~ Pretty))
# Get Pearson correlations
c <- data_all %>% 
  select(all_of(regression_variables)) %>% 
  set_names(as.character(to_pretty_vector(names(.), d))) %>%
  cor()

mynames <- str_sort(colnames(c), numeric=TRUE)
c <- c[mynames, mynames]

c2 <- c %>% as_tibble(rownames = "Phenotype")
print.data.frame(c2)

# Save data
filename <- sprintf("%s/deferral_correlations.tsv", table_path)
write_tsv(c2, filename)

# Save corrplot as pdf
filename <- sprintf("%s/deferral_correlations.pdf", fig_path)
if (save_figs) cairo_pdf(filename)
corrplot::corrplot(c)
if (save_figs) dev.off()

# Save corrplot as png
filename <- sprintf("%s/deferral_correlations.png", fig_path)
if (save_figs) png(filename, width =  5.5 * 300, height = 5.5 * 300, res = 300)
corrplot::corrplot(c, tl.col = "black", tl.cex = 0.5, type = "lower")
if (save_figs) dev.off()
```


### 3.2.4 Effect sizes

Krista: Jarkko had made his own functions and I used them first, but he has since switched to broom::tidy(fit, conf.int=TRUE, exponentiate = TRUE).
I will do with the later one.

```{r Create descript2}
# Create descript were the boolean TRUE is part of the variable name
descript2 <- descript %>%
  mutate(Variable2 = ifelse(Type=="boolean", sprintf("%sTRUE", Variable), Variable))
```

```{r Coefficients and confidence intervals freq model}
filename <- sprintf("%s/freq_cis.tsv", table_path)

# Additional data sets tested
# filename <- sprintf("%s/freq_before_CRM_cis.tsv", table_path)
# filename <- sprintf("%s/freq_cox_vars_cis.tsv", table_path)
# filename <- sprintf("%s/freq_cox_vars_before_CRM_cis.tsv", table_path)

if (recompute | !file.exists(filename)) {
  freq_cis <- broom::tidy(fit, conf.int = TRUE, exponentiate = TRUE) %>%
  rename(low = conf.low, high = conf.high) %>%
  left_join(descript2, by = c(term = "Variable2")) %>%
  filter(term != "(Intercept)") %>%
  mutate(Pretty = ifelse(is.na(Pretty), term, Pretty)) %>%
  mutate(Pretty = as.factor(Pretty))

  write_tsv(freq_cis, file=filename)
} else {
  freq_cis <- read_tsv(filename)
  cat("Loaded precomputed freq_cis.")
}
```

```{r Plotting normalized effect sizes for freq model}

# Plot normalized effect sized for fit
freq_cis %>%
  mutate(Pretty = fct_rev(Pretty)) %>%
  ggplot(aes(x = estimate, xmin = low, xmax = high, y = term)) + #y = Pretty for Pretty labs for y
  geom_vline(aes(xintercept = 1), color = "gray", size = 1) +
  geom_pointrange(position = position_dodge(width = 1)) +
  labs(title = "Frequentist_all", x = "Odds ratio", y = "Standardized variables") +
  scale_x_log10()

if (save_figs) {
  # Save plot
  filename <- sprintf("%s/normalised_effect_sizes.png", fig_path)
  ggsave(filename=filename,  width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
}

```

```{r Coefficients and confidence intervals to freq group models}
#mygroups <- c("all", "male", "female") #"pre_menopausal_female", "post_menopausal_female")

freq_cis_helper <- function(fit) {
  
  tidy_cis <- broom::tidy(fit, conf.int = TRUE, exponentiate = TRUE)
  
  freq_cis <- tidy_cis %>%
    rename(low = conf.low, high = conf.high) %>%
    left_join(descript2, by = c(term = "Variable2")) %>%
    filter(term != "(Intercept)") %>%
    mutate(Pretty = ifelse(is.na(Pretty), term, Pretty)) %>%
    mutate(Pretty = as.factor(Pretty))
  
  return(freq_cis)
}

filename <- sprintf("%s/freq_groups_cis.tsv", table_path)

# Additional data sets tested
# filename <- sprintf("%s/freq_before_CRM_groups_cis.tsv", table_path)
# filename <- sprintf("%s/freq_cox_vars_groups_cis.tsv", table_path)
# filename <- sprintf("%s/freq_cox_vars_before_CRM_groups_cis.tsv", table_path)


if (recompute | !file.exists(filename)) {
  freq_cis_groups <- map_dfr(freq_fits_list, freq_cis_helper, .id = "group")
  write_tsv(freq_cis_groups, file=filename)
} else {
  freq_cis_groups <- read_tsv(filename)
  cat("Loaded precomputed freq_cis_groups")
}
```

```{r Plotting normalized effect sizes for freq group models,fig.dim=c(8,12)}
# Testing the plotting
# freq_cis_groups %>%
#   #filter(!group == "male") %>%
#   mutate(Pretty = fct_rev(Pretty)) %>%
#   mutate(group = factor(group)) %>%
#   mutate(hollow_group = factor(ifelse(low<=1 & high>=1, NA_character_, as.character(group)),
#                                levels=levels(group))) %>%
#   ggplot(aes(x = estimate, xmin = low, xmax = high, y = Pretty, color = group)) +
#   stat_stripes(aes(stripe=Pretty), alpha=0.5, fill="lightgray") +
#   geom_vline(aes(xintercept = 1), color = "gray", size = 1) +
#   ggstance::geom_linerangeh(position=position_dodge(width=1))+#, size=0.2) +
#   geom_pointrange(position = position_dodge(width = 1), size = 0.25) +
#   labs(title = "Freq all", x = "Odds ratio", y = "Standardized variables") +
#   scale_colour_manual(values = cohort_colors[mygroups],
#                       labels = cohort_names[mygroups]) +
#   #coord_cartesian(xlim = c(0.1, 12)) +
#   scale_x_log10()

# Plotting effect size forest plots
freq_cis_groups %>%
  mutate(Pretty = fct_rev(Pretty)) %>%
  mutate(group = factor(group)) %>%  # Ensure 'group' is a factor
  mutate(hollow_group = factor(ifelse(low <= 1 & high >= 1, NA_character_, as.character(group)), 
                               levels = levels(group))) %>%
  ggplot(aes(x = estimate, xmin = low, xmax = high, y = term, color = group, fill = hollow_group)) + # y=Pretty for Pretty labs 
  stat_stripes(aes(stripe = Pretty), alpha = 0.5, fill = "lightgray") +
  geom_vline(aes(xintercept = 1), color = "gray", size = 1) +
  ggstance::geom_linerangeh(position = position_dodge(width = 1)) +
  geom_point(shape = 21, size = 1.5, position = position_dodge(width = 1)) +
  labs(title = "Freq cis groups: before CRM-cox vars", x = "Odds ratio", y = "Standardized variables") + 
  scale_colour_manual(values = cohort_colors[mygroups], labels = cohort_names[mygroups]) +
  scale_fill_manual(guide = "none", values = cohort_colors[mygroups], na.value = NA) +
  scale_x_log10() +
  guides(color = guide_legend(override.aes = list(shape = 16)))

if (save_figs) {
  # Additional data sets tested
  # filename <- sprintf("%s/freq_groups_normalised_cis.png", fig_path)
  # filename <- sprintf("%s/freq_before_CRM_groups_cis.png", fig_path)
  # filename <- sprintf("%s/freq_cox_vars_groups_cis.png", fig_path)
  
  filename <- sprintf("%s/freq_cox_vars_before_CRM_groups_cis.png", fig_path)
  ggsave(filename=filename,  width = 180,  height = 300, units="mm", dpi=300, scale=1.0, device="png")
}

```


## 3.3. Logistic regression with interactions

```{r Define frequentist interaction models}

freq_int_formula_all <- as.formula(sprintf("Hb_deferral ~ %s", paste(c(regression_variables, "female", interactions), collapse=" + ")))
print(freq_int_formula_all)

freq_int_formula_male <- as.formula(sprintf("Hb_deferral ~ %s", paste(setdiff(regression_variables,
                                                                              c("snp_6_68206710", "snp_11_5226799"
                                                                              #"recent_deferrals"
                                                                              )), collapse=" + ")))
print(freq_int_formula_male)

freq_int_formula_female <- as.formula(sprintf("Hb_deferral ~ %s", paste(c(regression_variables, 
                                                                          "group:snp_22_37066896",
                                                                          "snp_1_169549811:group"), collapse=" + ")))
print(freq_int_formula_female)

# UNCOMMENT if needed
# freq_int_formula_pre_menopausal_female <- as.formula(sprintf("Hb_deferral ~ %s", 
#                                                              paste(setdiff(variables, "snp_6_22583313"), 
#                                                                    collapse=" + ")))
# 
# freq_int_formula_post_menopausal_female <- as.formula(sprintf("Hb_deferral ~ %s", 
#                                                               paste(setdiff(variables,
#                                                                             c("snp_6_21989753", "snp_6_22583313",
#                                                                               "snp_6_23835557", "snp_7_75844637",
#                                                                               "snp_11_5226799", "snp_15_45099877",
#                                                                               "recent_deferrals")),
#                                                                     collapse=" + ")))
# print(freq_int_formula_pre_menopausal_female)
# print(freq_int_formula_post_menopausal_female)

interaction_formulas <- list(all=freq_int_formula_all, 
                             male = freq_int_formula_male, 
                             female = freq_int_formula_female)
                             # UNCOMMET if needed
                             # pre_menopausal_female=freq_int_formula_pre_menopausal_female,
                             # post_menopausal_female=freq_int_formula_post_menopausal_female)

```

### 3.3.1. Fit models and fir summaries

```{r Fit frequentist interaction models}

fit_freq_int_helper <- function(group, data, formula) {
  filename <- sprintf("%s/freq_int_fit_%s.rds", base, group)
  if (recompute | !file.exists(filename)) {
    freq_int_fit <- stats::glm(formula,
                           data = data,
                           family = "binomial")
    saveRDS(freq_int_fit, filename)
  } else {
    cat(sprintf("Loading prefitted freq logistic model with interactions for Hb-deferral on group %s\n", group))
    freq_int_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(freq_int_fit)))
}

freq_int_input <- tibble(group=setdiff(names(cohort_colors), c("pre_menopausal_female", "post_menopausal_female")),
                         data=datas,
                         formula=interaction_formulas)
freq_int_fits <- pmap_dfr(freq_int_input, fit_freq_int_helper)
freq_int_fits_list <- deframe(freq_int_fits)

# freq_int_fits <- map2(datas, interaction_formulas, 
#                       function(data, formula) stats::glm(formula, data = data, family = binomial))

```

```{r Save freq_int_fits as a list}
filename <- sprintf("%s/freq_int_fits_list.rds", base)
saveRDS(freq_int_fits_list, filename)
```

```{r Summary model freq_int - all}
summary(freq_int_fits_list$all)
```

```{r Summary model freq_int - male}
summary(freq_int_fits_list$male)
```

```{r Summary model freq_int - female}
summary(freq_int_fits_list$female)
```

```{r Summary model freq_int - pre and post}
# UNCOMMENT if needed
# summary(freq_int_fits_list$pre_menopausal_female)
# summary(freq_int_fits_list$post_menopausal_female)
```

### 3.3.2. Diagnostics

#### Cook' distance

```{r Cooks distances - freq}

filename <- sprintf("%s/cooks_dictance_freq_int.png", fig_path)
if (save_figs) png(filename, width = 600, height = 400)
plot(fit, which = 4)
if (save_figs) dev.off()

```

#### Check for multicollinearity

```{r Check for multicollinearity - freq_int}
freq_int_vifs <- t(map_dfr(freq_int_fits_list, function(x) as_tibble(t(car::vif(x, type="predictor"))))) %>% 
  as_tibble(rownames = "Variable")
colnames(freq_int_vifs) <- c("Variable", "x", "y", "all", "male", "female")
filename <- sprintf("%s/deferral_vifs_freq_int.tsv", table_path)
write_tsv(freq_int_vifs, filename)
```

```{r Create colored table of the VIFs - freq_int}
# Create a gt table with colored cells
gt_table <- freq_int_vifs %>%
  select(-x, -y) %>%
  mutate(Variable = to_pretty_vector(Variable, descript)) %>%
  mutate(Variable = case_when(Variable == "smoking:female" ~ "Smoking:Female",
                              Variable == "snp_1_169549811:group" ~ "SNP 1:169549811:Group",
                              Variable == "snp_22_37066896:group" ~ "SNP 22:37066896:Group",
                              TRUE ~ Variable)) %>%
  gt() %>%
  tab_header(
    title = "(b) VIFs for LogRInt Models",
  ) %>%
  cols_label(
    Variable = "Variable"
  ) %>%
  fmt_number(
    columns = vars(-Variable),
    decimals = 2
  ) %>%
  data_color(
    columns = vars(-Variable),
    colors = scales::col_bin(
      bins = c(0, 5, Inf),
      palette = c("white", "red")
    )
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_body(columns = everything())
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_column_labels(columns = everything())
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_stub()
  )

filename <- sprintf("%s/VIFs_freq_int.png", fig_path)
gtsave(gt_table, filename, vwidth = 300)

filename <- sprintf("%s/VIFs_freq_int.pdf", fig_path)
gtsave(gt_table, filename)


# Print the gt table
print(gt_table)
```

```{r Combine the VIF tables for freq and freq_int}

# Combine the two images side by side
img1 <- image_read(sprintf("%s/VIFs_freq.png", fig_path))
img2 <- image_read(sprintf("%s/VIFs_freq_int.png", fig_path))
combined_img <- image_append(c(img1, img2), stack = FALSE)

# Save the combined image
filename <- sprintf("%s/combined_VIF_tables.png", fig_path)
image_write(combined_img, "combined_VIF_tables.png")
combined_img <- image_append(c(img1, img2), stack = FALSE)

# Save the combined image
filename <- sprintf("%s/combined_VIF_tables.png", fig_path)
image_write(combined_img, filename)
```

### 3.3.3. Effect sizes

```{r Coefficients and confidence intervals of frequentist interaction models}

#mygroups <- c("all", "male", "female", "pre_menopausal_female", "post_menopausal_female")

freq_int_cis_helper <- function(fit) {

  tidy_cis <- broom::tidy(fit, conf.int = TRUE, exponentiate = TRUE)

  freq_int_cis <- tidy_cis %>%
    rename(low = conf.low, high = conf.high) %>%
    left_join(descript2, by = c(term = "Variable2")) %>%
    filter(term != "(Intercept)") %>%
    mutate(Pretty = ifelse(is.na(Pretty), term, Pretty)) %>%
    mutate(Pretty = as.factor(Pretty))

  return(freq_int_cis)
}

filename <- sprintf("%s/freq_int_groups_cis.tsv", table_path)

if (recompute | !file.exists(filename)) {
  freq_int_cis_groups <- map_dfr(freq_int_fits_list, freq_int_cis_helper, .id = "group")
  write_tsv(freq_int_cis_groups, file=filename)
} else {
  freq_int_cis_groups <- read_tsv(filename)
  cat("Loaded precomputed freq_int_cis_groups")
}

```

```{r Plotting normalized effect sizes for freq with interactions group models, fig.dim=c(8,12)}

freq_int_cis_groups %>%
  mutate(Pretty = fct_rev(Pretty)) %>%
  mutate(group = factor(group)) %>%  # Ensure 'group' is a factor
  mutate(hollow_group = factor(ifelse(low <= 1 & high >= 1, NA_character_, as.character(group)),
                               levels = levels(group))) %>%
  ggplot(aes(x = estimate, xmin = low, xmax = high, y = term, color = group, fill = hollow_group)) + #y = Pretty for Pretty labs for y
  stat_stripes(aes(stripe = Pretty), alpha = 0.5, fill = "lightgray") +
  geom_vline(aes(xintercept = 1), color = "gray", size = 1) +
  ggstance::geom_linerangeh(position = position_dodge(width = 1)) +
  geom_point(shape = 21, size = 1.5, position = position_dodge(width = 1)) +
  labs(title = "Freq with interactions cis groups", x = "Odds ratio", y = "Standardized variables") +
  scale_colour_manual(values = cohort_colors[mygroups], labels = cohort_names[mygroups]) +
  scale_fill_manual(guide = "none", values = cohort_colors[mygroups], na.value = NA) +
  scale_x_log10() +
  guides(color = guide_legend(override.aes = list(shape = 16)))

if (save_figs) {
  filename <- sprintf("%s/freq_int_groups_normalised_cis.png", fig_path)
  ggsave(filename=filename,  width = 180,  height = 300, units="mm", dpi=300, scale=1.0, device="png")
}

```

```{r}
# Chenking
#table(freq_int_cis_groups$group, useNA = "ifany")
```

## 3.4. Bayesian logistic regression

### 3.4.1. Define model parameters and formulas for Bayesian logistic models

```{r Parameters for Bayesian models}
iterations <- 1000
cores <- 4
```

Jarkko had reported to run out of memory with more 4 cores.
My computer has 10 cores. I need to test how many can I use without filling the memory
or hindering the computer otherwise. *I was able to use 4 cores to do these model fittings.*

```{r Define formulas for Bayesian logistic models}
bayes_formula_all <- as.formula(sprintf("Hb_deferral ~ %s", 
                                        paste(c(regression_variables, "female", interactions), collapse=" + ")))
print(bayes_formula_all)

bayes_formula_male <- as.formula(sprintf("Hb_deferral ~ %s", paste(setdiff(regression_variables,
                                                                           c("snp_6_68206710", "snp_11_5226799"
                                                                            #"snp_7_75844637", 
                                                                            #"snp_22_29795932",
                                                                            #"recent_deferrals"
                                                                            )), collapse=" + ")))
print(bayes_formula_male)

bayes_formula_female <- as.formula(sprintf("Hb_deferral ~ %s", paste(c(regression_variables,
                                                                       "group:snp_22_37066896",
                                                                       "snp_1_169549811:group"), collapse=" + ")))
print(bayes_formula_female)

# UNCOMMENT if needed
# bayes_formula_pre_menopausal_female <- as.formula(sprintf("Hb_deferral ~ %s", 
#                                                           paste(setdiff(variables, "snp_6_22583313"), collapse=" + ")))
# print(bayes_formula_pre_menopausal_female)
# 
# bayes_formula_post_menopausal_female <- as.formula(sprintf("Hb_deferral ~ %s", 
#                                                            paste(setdiff(variables,
#                                                                          c("snp_6_21989753", "snp_6_22583313",
#                                                                            "snp_6_23835557", "snp_7_75844637",
#                                                                            "snp_11_5226799", "snp_15_45099877",
#                                                                            "recent_deferrals")), collapse=" + ")))
# print(bayes_formula_post_menopausal_female)
```

```{r Data and formula lists for bayes model }
datas <-list(all=data_all, male=data_male, female=data_female)
             # UNCOMMENT if needed
             # pre_menopausal_female=data_pre_menopausal_female,
             # post_menopausal_female=data_post_menopausal_female)

bayesian_formulas <- list(all=bayes_formula_all, 
                          male=bayes_formula_male, 
                          female=bayes_formula_female)
             # UNCOMMENT if needed
             # pre_menopausal_female=bayes_formula_pre_menopausal_female,
             # post_menopausal_female=bayes_formula_post_menopausal_female)
```

### 3.4.2. Priors

Flat prior is used for every parameter except the Intercept and sigma are student_t distributed.

```{r Show the used priors - male}
get_prior(bayes_formula_all, data_all)
```

```{r Show the used priors - male}
# UNCOMMENT to check should be same for all the data sets
# get_prior(bayes_formula_male, data_male)
```

```{r Show the used priors - female}
# UNCOMMENT to check should be same for all the data sets
# get_prior(bayes_formula_female, data_female)
```


### 3.4.3. Fit models

```{r Fit all Bayesian models}
# Function to help with model fitting
fit_bayesian_helper <- function(group, data, formula) {
  filename <- sprintf("%s/bayesian_fit_%s.rds", base, group)
  
  if (recompute | !file.exists(filename)) { 
    cat(sprintf("Fitting Bayesian logistic model for Hb-deferral on group %s\n", group))
    bayesian_fit <- brm(formula,
                        data = data, 
                        family = bernoulli(),
                        file = NULL,
                        control = list(max_treedepth = 14),
                        #control = if (group == "all") list(max_treedepth = 13) else list(max_treedepth = 14),
                        #refresh = 0,
                        cores = cores,
                        iter = iterations
    )
    saveRDS(bayesian_fit, filename)
  } else {
    cat(sprintf("Loading prefitted Bayesian logistic model for Hb-deferral on group %s\n", group))
    bayesian_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(bayesian_fit)))
}


bayesian_input <- tibble(group=setdiff(names(cohort_colors), c("pre_menopausal_female", "post_menopausal_female")),
                         data=datas,
                         formula=bayesian_formulas)
bayesian_fits <- pmap_dfr(bayesian_input, fit_bayesian_helper)
bayesian_fits_list <- deframe(bayesian_fits)
```

```{r Save bayesian_fits as a list}
filename <- sprintf("%s/bayesian_fits_list.rds", base)
saveRDS(bayesian_fits_list, filename)
```

### 3.4.4. Diagnostics

Markov chain Monte Carlo methods needs to check if chains are converged.

#### Trace

```{r Dafault trace plots, fig.dim=c(12,12)}
helper <- function(group, fit) {
  bp <- bayesplot::mcmc_trace(as_draws_array(fit, inc_warmup = TRUE), n_warmup = iterations/2) +
    ggtitle(sprintf("Trace for BayesLogR for group: %s", group))
  
  if (save_figs) {
    filename <- sprintf("%s/bayes_traces_%s.pdf", fig_path, group)
    ggsave(filename=filename, plot=bp, width=380, height=300, units="mm", dpi=300, scale=1.0, device="pdf")
    
    filename <- sprintf("%s/bayes_traces_%s.png", fig_path, group)
    ggsave(filename=filename, plot=bp, width=380, height=300, units="mm", dpi=300, scale=1.0, device="png")
    
  }
  bp
}

pmap(bayesian_fits, helper)
```

```{r Test - Prettier and clearer trace plots, eval=FALSE}
# UNCOMMEND if clearer plots are needed
# helper <- function(group, fit) {
#   # Convert fit to array and include warmup
#   draws_array <- as_draws_array(fit, inc_warmup = TRUE)
#   n_col <- ncol(as_draws_df(draws_array))
#   
#   original_labels <- colnames(as_draws_df(draws_array))[1:(n_col-3)]
#   
#   new_labels <- c("b_Intercept" = "b_Intercept", "b_previous_Hb" = "Previous Hb", "b_smokingTRUE" = "Smoking",
#                   "b_age" = "Age", "b_blood_volume" = "Blood volume", "b_year" = "Year", "b_warm_seasonTRUE" = "Warm Season",
#                   "b_days_to_previous_fb" = "Days to previous fbd", "b_recent_donations" = "Recent donations",
#                   "b_recent_deferrals" = "Recent deferral", "b_snp_1_113834946" = "SNP 1:113834946", 
#                   "b_snp_1_169549811" = "SNP 1:169549811", "b_snp_4_25970243" = "SNP 4:25970243", 
#                   "b_snp_6_25857692" = "SNP 6:6_25857692", "b_snp_6_32617727" = "SNP 6:32617727",
#                   "b_snp_6_32658525" = "SNP 6:32658525", "b_snp_6_68206710" = "SNP 6:68206710",
#                   "b_snp_7_75844637" = "SNP 7:75844637", "b_snp_8_10785723" = "SNP 8:10785723",
#                   "b_snp_8_23520397" = "SNP 8:23520397", "b_snp_8_75503352" = "SNP 8:75503352",
#                   "b_snp_9_133271182" = "SNP 9:133271182", "b_snp_10_63174788" = "SNP 10:63174788",
#                   "b_snp_11_5226799" = "SNP 11:5226799", "b_snp_12_6030341" = "SNP 12:6030341",
#                   "b_snp_14_33938877" = "SNP 14:33938877", "b_snp_15_45099877" = "SNP 15:45099877",
#                   "b_snp_17_58358769" = "SNP 17:58358769", "b_snp_20_35186730" = "SNP 20:35186730",
#                   "b_snp_22_29795932" = "SNP 22:29795932", "b_snp_22_37066896" = "SNP 22:37066896",
#                   "b_femaleTRUE" = "Female", "b_smokingTRUE:femaleTRUE" = "Smoking:Female",
#                   "b_snp_22_37066896:grouppost_menopausal_female" = "SNP 22:37066896:Post Menopausal Female",
#                   "b_snp_22_37066896:grouppre_menopausal_female" = "SNP 22:37066896:Pre Menopausal Female",
#                   "b_snp_1_169549811:grouppost_menopausal_female" = "SNP 1:169549811:Post Menopausal Female",
#                   "b_snp_1_169549811:grouppre_menopausal_female" =  "SNP 1:169549811:Pre Menopausal Female",
#                   "Intercept" = "Intercept", "lprior" = "lprior", "lp__")
#   
#   # Create trace plot with customization
#   bp <- mcmc_trace(draws_array, pars = original_labels, n_warmup = iterations / 2) +
#     ggtitle(sprintf("Trace for BayesLogR for group: %s", group)) +
#     facet_wrap(~parameter, scales = "free_y", ncol = 3, 
#                labeller = labeller(parameter = new_labels)) +  # Facet wrap for variables
#     scale_color_manual(values = c(c("#0072B2", "#E69F00", "#009E73", "#CC79A7"))) +  # Color coding for chains
#     theme_minimal() +  # Minimal theme for better readability
#     theme(legend.position = "right", # Position legend at the bottom
#           plot.title = element_text(size = 15),  # Increase title size
#           strip.text = element_text(size = 10),
#           legend.title = element_text(size = 15),
#           legend.text = element_text(size = 15),# Increase legend text size
#           legend.key.size = unit(3, "lines")) +  # Increase legend key size
#     guides(color = guide_legend(override.aes = list(size = 2)))  # Thicker lines in legend
#   
#   
#   # Save figures if required
#   if (save_figs) {
#     pdf_filename <- sprintf("%s/bayes_traces_%s.pdf", fig_path, group)
#     png_filename <- sprintf("%s/bayes_traces_%s.png", fig_path, group)
#     
#     ggsave(filename = pdf_filename, plot = bp, width = 210, height = 297, units = "mm", dpi = 300, device = "pdf")
#     ggsave(filename = png_filename, plot = bp, width = 210, height = 297, units = "mm", dpi = 300, device = "png")
#   }
#   
#   return(bp)
# }
# 
# pmap(bayesian_fits, helper)
```

```{r Final - Prettier and clearer trace plots, eval=FALSE}
# UNCOMMENT if needed
# This produces trace plots on multiple pages
# helper <- function(group, fit) {
#   # Convert fit to array and include warmup
#   draws_array <- as_draws_array(fit, inc_warmup = TRUE)
#   n_col <- ncol(as_draws_df(draws_array))
#   
#   original_labels <- colnames(as_draws_df(draws_array))[1:(n_col-3)]
#   
#   new_labels <- c("b_Intercept" = "b_Intercept", "b_previous_Hb" = "Previous Hb", "b_smokingTRUE" = "Smoking",
#                   "b_age" = "Age", "b_blood_volume" = "Blood volume", "b_year" = "Year", "b_warm_seasonTRUE" = "Warm Season",
#                   "b_days_to_previous_fb" = "Days to previous fbd", "b_recent_donations" = "Recent donations",
#                   "b_recent_deferrals" = "Recent deferral", "b_snp_1_113834946" = "SNP 1:113834946", 
#                   "b_snp_1_169549811" = "SNP 1:169549811", "b_snp_4_25970243" = "SNP 4:25970243", 
#                   "b_snp_6_25857692" = "SNP 6:6_25857692", "b_snp_6_32617727" = "SNP 6:32617727",
#                   "b_snp_6_32658525" = "SNP 6:32658525", "b_snp_6_68206710" = "SNP 6:68206710",
#                   "b_snp_7_75844637" = "SNP 7:75844637", "b_snp_8_10785723" = "SNP 8:10785723",
#                   "b_snp_8_23520397" = "SNP 8:23520397", "b_snp_8_75503352" = "SNP 8:75503352",
#                   "b_snp_9_133271182" = "SNP 9:133271182", "b_snp_10_63174788" = "SNP 10:63174788",
#                   "b_snp_11_5226799" = "SNP 11:5226799", "b_snp_12_6030341" = "SNP 12:6030341",
#                   "b_snp_14_33938877" = "SNP 14:33938877", "b_snp_15_45099877" = "SNP 15:45099877",
#                   "b_snp_17_58358769" = "SNP 17:58358769", "b_snp_20_35186730" = "SNP 20:35186730",
#                   "b_snp_22_29795932" = "SNP 22:29795932", "b_snp_22_37066896" = "SNP 22:37066896",
#                   "b_femaleTRUE" = "Female", "b_smokingTRUE:femaleTRUE" = "Smoking:Female",
#                   "b_snp_22_37066896:grouppost_menopausal_female" = "SNP 22:37066896:Post Menopausal Female",
#                   "b_snp_22_37066896:grouppre_menopausal_female" = "SNP 22:37066896:Pre Menopausal Female",
#                   "b_snp_1_169549811:grouppost_menopausal_female" = "SNP 1:169549811:Post Menopausal Female",
#                   "b_snp_1_169549811:grouppre_menopausal_female" =  "SNP 1:169549811:Pre Menopausal Female",
#                   "Intercept" = "Intercept", "lprior" = "lprior", "lp__")
#   
#   # Split parameters into two groups
#   params_group1 <- original_labels[1:30]
#   params_group2 <- original_labels[31:length(original_labels)]
#   
#   # Create trace plots for each group
#   bp1 <- mcmc_trace(draws_array, pars = params_group1, n_warmup = iterations / 2) +
#     ggtitle(sprintf("Trace for BayesLogR for group: %s 1", group)) +
#     facet_wrap(~parameter, scales = "free_y", ncol = 3, 
#                labeller = labeller(parameter = new_labels)) +
#     scale_color_manual(values = c("#0072B2", "#E69F00", "#009E73", "#CC79A7")) +
#     theme_minimal() +
#     theme(legend.position = "right",
#           plot.title = element_text(size = 15),
#           strip.text = element_text(size = 10),
#           legend.title = element_text(size = 15),
#           legend.text = element_text(size = 15),
#           legend.key.size = unit(3, "lines")) +
#     guides(color = guide_legend(override.aes = list(size = 2)))
#   
#   bp2 <- mcmc_trace(draws_array, pars = params_group2, n_warmup = iterations / 2) +
#     ggtitle(sprintf("Trace for BayesLogR for group: %s 2", group)) +
#     facet_wrap(~parameter, scales = "free_y", ncol = 3, 
#                labeller = labeller(parameter = new_labels)) +
#     scale_color_manual(values = c("#0072B2", "#E69F00", "#009E73", "#CC79A7")) +
#     theme_minimal() +
#     theme(legend.position = "right",
#           plot.title = element_text(size = 15),
#           strip.text = element_text(size = 10),
#           legend.title = element_text(size = 15),
#           legend.text = element_text(size = 15),
#           legend.key.size = unit(3, "lines")) +
#     guides(color = guide_legend(override.aes = list(size = 2)))
#   
#   # Save figures if required
#   if (save_figs) {
#     pdf_filename1 <- sprintf("%s/bayes_traces_%s_page1.pdf", fig_path, group)
#     pdf_filename2 <- sprintf("%s/bayes_traces_%s_page2.pdf", fig_path, group)
#     png_filename1 <- sprintf("%s/bayes_traces_%s_page1.png", fig_path, group)
#     png_filename2 <- sprintf("%s/bayes_traces_%s_page2.png", fig_path, group)
#     
#     ggsave(filename = pdf_filename1, plot = bp1, width = 210, height = 297, units = "mm", dpi = 300, device = "pdf")
#     ggsave(filename = pdf_filename2, plot = bp2, width = 210, height = 297, units = "mm", dpi = 300, device = "pdf")
#     ggsave(filename = png_filename1, plot = bp1, width = 210, height = 297, units = "mm", dpi = 300, device = "png")
#     ggsave(filename = png_filename2, plot = bp2, width = 210, height = 297, units = "mm", dpi = 300, device = "png")
#   }
#   
#   return(list(bp1, bp2))
# }
# 
# pmap(bayesian_fits, helper)
```


#### Auto-correlation

```{r Autocorrelation plots, fig.dim=c(10,15)}
helper <- function(group, fit) {
  g <- mcmc_plot(fit, type = "acf_bar") + labs(title= sprintf("Autocorrelation for BayesLogR for group: %s", group))
  if (save_figs) {
    filename <- sprintf("%s/bayes_auto_correlations_%s.pdf", fig_path, group)
    ggsave(filename=filename, plot=g, width=800, height=300, units="mm", dpi=300, scale=1.0, device="pdf")
    
    filename <- sprintf("%s/bayes_auto_correlations_%s.png", fig_path, group)
    ggsave(filename=filename, plot=g, width=800, height=300, units="mm", dpi=300, scale=1.0, device="png")
  }
  g
}
pmap(bayesian_fits, helper)
```

#### Rhats
Check Rhats to see if we converged.

```{r Plot Rhats}
helper <- function(group, fit) {
  g <- mcmc_plot(fit, type = "rhat") + labs(title= sprintf("Rhats for BayesLogR for group: %s", group))
  if (save_figs) {
    filename <- sprintf("%s/bayes_rhats_%s.pdf", fig_path, group)
    ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="pdf")
    
    filename <- sprintf("%s/bayes_rhats_%s.png", fig_path, group)
    ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  }
  g
}

pmap(bayesian_fits, helper)
```

9.9.Iterations = 1000: All other groups reached convergence except male, but that's due to the separation with SNP 1:169549811.
New coding for dosages for this snp is needed!

11.9. Dosage for one snp has been changed and in the end removed from the models.
Iterations = 100: convergence not looking like before. Male look like it has reached it, but
the others not so much. And there were warnings while computing happened. More iterations suggested.

20.9. snp 1 is back to female models. Iterations 500.

15.10. Iterations = 500. Rhats look fine for all the groups. Post-menopausal females took longer to converge.

5.11. Iterations = 500, cores = 4. Rhats look fine.

7.11. Iterations = 1000, cores = 4. Rhats for males don't look nice...

12.11. Iterations = 1000, cores = 4. Rhats look fine for all the groups.

4.12. Iterations = 1000, cores = 4. Rhats look fine for all the groups.

3.2.2025. Iterations = 1000, cores = 4, Rhats look fine for all groups.

### 3.4.5. Effect distibutions

```{r Function for forest plot Bayesian models with mcmc_areas}

variables2 <- descript2 %>% 
  filter(Variable2 %in% c(regression_variables, "female", interactions)) %>%
  #mutate(Variable2 = case_when(Variable2 == "warm_seasonTRUE"  ~ "warm_season",
  #                             TRUE ~ Variable2)) %>%
  arrange(Pretty) %>% pull(Variable2) %>% unique %>% rev

bvariables <- if_else(variables2 != "(Intercept)", sprintf("b_%s", variables2), "b_Intercept")

# Jarkko: This self-made version has pretty labels unlike the previous function
# Krista: This works only in the male models have all the variables in the Variables2
forest_plot2 <- function(fit, id) {
  a <- as.array(fit, variable=bvariables)
  tmp <- mcmc_areas_data(a, 
                         prob = 0.95,
                         area_method = "equal area",
                         #variable = variables2,
                         transformations = "exp"
  )
  
  tmp2 <- tmp %>% 
    filter(parameter != "exp(b_intercept)") %>% 
    mutate(parameter = str_match(parameter, "exp\\(b_(.*)\\)")[,2]) %>%
    inner_join(descript2, by=c(parameter = "Variable2")) %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    mutate(Pretty = fct_rev(Pretty))
  
  g2 <- tmp2 %>% 
    filter(interval == "inner") %>% 
    ggplot(aes(x=x, y=Pretty, height=plotting_density)) + 
    geom_ridgeline(scale=0.9) +  # Shaded area ("inner")
    geom_ridgeline(mapping=aes(x=x, y=Pretty, height=plotting_density), # The black outline ("outer")
                   data=tmp2 %>% filter(interval=="outer"), 
                   fill=NA, scale=0.9) +
    scale_y_discrete() +
    labs(title = id, x="Odds ratio", y="Variable") +
    scale_x_log10()
}

```

```{r Effect distibutions forest plot - all}
g <- forest_plot2(bayesian_fits_list$all, "all")
g
```

```{r Effect distibutions forest plot - male}
# UNCOMMENT if could work
# This works only in the male models have all the variables in the Variables2
# g <- forest_plot2(bayesian_fits_list$male, "male")
# g
```

Error due to the missing snps.

```{r Effect distibutions forest plot - female}
g <- forest_plot2(bayesian_fits_list$female, "female")
g
```

```{r Effect distibutions forest plot - pre and post}
# UNCOMMENT if needed
# This works only in the male models have all the variables in the Variables2
# g <- forest_plot2(bayesian_fits_list$pre_menopausal_female, "pre_menopausal_female")
# g
# 
# g <- forest_plot2(bayesian_fits_list$post_menopausal_female, "post_menopausal_female")
# g
```

Errors for males and post-menopausal females due to the missing snps and recent_deferrals in the formulas.


### 3.4.6. Effect sizes

```{r Functions for bayes intervals}
get_bayes_intervals <- function(bayesian_fit) {
  bayes_cis <- mcmc_intervals_data(as_draws_array(bayesian_fit), 
                                   point_est="mean", regex_pars = "^b_.*", prob = 0, prob_outer = 0.95)
  bayes_cis <- bayes_cis %>% 
    rename(term=parameter, estimate=m, low=ll, high=hh) %>%
    mutate(term = str_remove(term, "b_")) %>%
    mutate(term = if_else(term=="Intercept", "(Intercept)", term)) %>%
    select(term, low, estimate, high)
  return(bayes_cis)
}

pretty_bayes_intervals <- function(bayesian_fits_list) {
  map_dfr(bayesian_fits_list, get_bayes_intervals, .id="group") %>%
    left_join(descript2, by=c(term = "Variable2")) %>%
    mutate(Pretty = ifelse(is.na(Pretty), term, Pretty)) %>%
    filter(term != "(Intercept)") %>%
    mutate(Pretty = as.factor(Pretty)) %>%
    mutate(group = factor(group, levels=names(cohort_colors))) %>%
    mutate(across(c(estimate, low, high), exp))
}
```

```{r Bayes cis}
filename <- sprintf("%s/bayes_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  bayes_cis <- pretty_bayes_intervals(bayesian_fits_list)
  write_tsv(bayes_cis, file=filename)
} else {
  bayes_cis <- read_tsv(filename)
  cat("Loaded precomputed bayes_cis.")
}
```

```{r Forest plot bayes cis, fig.dim=c(8,12)}
# Test version
# g <- bayes_cis %>%
#   #filter(!Group == "male") %>%
#   mutate(Group = factor(Group, levels = names(cohort_colors)),
#          Pretty = factor(Pretty, levels = str_sort(unique(Pretty), numeric=TRUE))) %>%
#   mutate(across(c(Group, Pretty), fct_rev)) %>%
#   ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Pretty, color=Group)) +
#   geom_vline(aes(xintercept=1), color="gray", size=1) +
#   geom_stripes(bayes_cis, Pretty) +
#   # geom_rect(data=make_stripes(bayes_cis, Pretty) %>% filter(stripe==1),
#   #           mapping=aes(ymax = as.numeric(Pretty) + 0.5,
#   #                       ymin = as.numeric(Pretty) - 0.5),
#   #           fill = "gray", xmin=-Inf, xmax=Inf, alpha = 0.5, 
#   #           show.legend = FALSE, colour=NA, inherit.aes = FALSE) +
#   ggstance::geom_pointrangeh(position=position_dodge(width=1), size=0.2) +
#   labs(title = "Bayesian", x="Odds ratio", y="Standardized variables") +
#   scale_colour_manual(values = cohort_colors) +
#   #coord_cartesian(xlim = c(0.1, 12)) +
#   scale_x_log10() +
#   scale_y_discrete()  # Jarkko: This is important. 
# # Solves the problem with position_dodge2 and the order of rect and pointrange geoms !!!!!!
# # Otherwise following error results: Error: Discrete value supplied to continuous scale

g <- bayes_cis %>% 
  mutate(Pretty = fct_rev(Pretty)) %>%
  mutate(group = factor(group)) %>%
  mutate(hollow_group = factor(ifelse(low <= 1 & high >= 1, NA_character_, as.character(group)), 
                               levels = levels(group))) %>%
  ggplot(aes(x = estimate, xmin = low, xmax = high, y = term, color = group, fill = hollow_group)) + # y = Pretty Pretty labs for y
  geom_vline(aes(xintercept = 1), color = "gray", size = 1) +
  stat_stripes(aes(stripe = Pretty), alpha = 0.5, fill = "lightgray") +
  ggstance::geom_linerangeh(position = position_dodge(width = 1), size = 0.2) + 
  geom_point(shape = 21, size = 1.5, position = position_dodge(width = 1)) +
  labs(title = "Bayesian cis groups", x = "Odds ratio", y = "Standardized variables") + 
  scale_colour_manual(values = cohort_colors[mygroups], labels = cohort_names[mygroups]) +
  scale_fill_manual(guide = "none", values = cohort_colors[mygroups], na.value = NA) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  #coord_cartesian(xlim = c(0.0001, 12)) +
  scale_x_log10() +
  scale_y_discrete()

if (save_figs) {
  filename <- sprintf("%s/bayes_cis.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 300, units="mm", dpi=300, scale=1.0, device="png")
}
g

```


## 3.5. Bayesian logistic regression with FULL SPLINES (Checking linearity)

**This takes really long time to run!!! I haven't done it with the whole data at all.**
**I have run this code once with sample size 10 000 for males and females and once**
**for the whole male and female regression_train data**

**I'm concentrating on using splines for some of the variables.**

- Checking if using splines would make the models better.

### 3.5.1. Define model prarameters and formulas

```{r}
full_spline_variables <- c("previous_Hb", "days_to_previous_fb", "age", "year", #"hour",
                           "recent_donations", "recent_deferrals",
                           "blood_volume") # Make these variables use splines

# UNCOMMENT if there is enough power in the computer
#full_spline_formula <- sprintf("Hb_deferral ~ %s", paste(sprintf("s(%s)", full_spline_variables), collapse=" + "))

full_spline_formula_male <- bf(Hb_deferral ~ s(previous_Hb, k = 10) + s(days_to_previous_fb, k = 10) + 
                                 s(age, k = 10) + s(year, k = 4) + s(recent_donations, k = 12) + 
                                 s(recent_deferrals, k = 5) + s(blood_volume, k = 10))
print(full_spline_formula_male)

full_spline_formula_female <- bf(Hb_deferral ~ s(previous_Hb, k = 10) + s(days_to_previous_fb, k = 10) + 
                                   s(age, k = 10) + s(year, k = 4) + s(recent_donations, k = 9) + 
                                   s(recent_deferrals, k = 5) + s(blood_volume, k = 10))
print(full_spline_formula_female)


full_spline_datas <- list(#all=data_all, # UNCOMMENT if possible
                          male=data_male, female=data_female)
                          # UNCOMMENT if needed
                          #pre_menopausal_female=data_pre_menopausal_female,
                          #post_menopausal_female=data_post_menopausal_female)

full_spline_formulas <- list(#all=full_spline_formula, # UNCOMMENT if possible
                          male=full_spline_formula_male, female=full_spline_formula_female)
                          # UNCOMMENT if needed
                          #pre_menopausal_female=full_spline_formula,
                          #post_menopausal_female=full_spline_formula)
```

HOX! there might be need for setting the degrees of freedoms (k) separately for all 
the models and variables.

```{r Checking the unique combinations - data _all}
# covariates <- data_all %>% select(previous_Hb, days_to_previous_fb, age, year, recent_donations,
#                                   recent_deferrals, blood_volume)
# unique_combinations <- covariates %>% distinct() %>% nrow()
# print(unique_combinations)
```

```{r Checking the unique combinations - data_male}
data_male %>% 
  summarise(across(c(previous_Hb, days_to_previous_fb, age, year, recent_donations, recent_deferrals, blood_volume), 
                   n_distinct))
```

```{r Checking the unique combinations - data_female}
data_female %>% 
  summarise(across(c(previous_Hb, days_to_previous_fb, age, year, recent_donations, recent_deferrals, blood_volume), 
                   n_distinct))
```


```{r}
# testing
# full_spline_data_male <- data_male %>%
#   select(Hb_deferral, previous_Hb, days_to_previous_fb, age, year, recent_deferrals,
#          recent_donations, blood_volume)
# #summary(full_spline_data_male)
# 
# full_spline_data_female <- data_female %>%
#     select(Hb_deferral, previous_Hb, days_to_previous_fb, age, year, recent_deferrals,
#          recent_donations, blood_volume)
```

### 3.5.2. Fit full spline models

Jarkko had problems running with memory becoming full with the all data.
I didn't even try the all data, because it took really long even with male and female.

```{r Fitting full spline bayesian models, eval = FALSE}
# code from deferral_logistic_and_cox.Rmd

filename <- sprintf("%s/full_spline_fit.rds", base)

fit_full_spline_helper <- function(group, data, formula) {
  filename <- sprintf("%s/full_spline_fit_%s.rds", base, group)
  
  if (recompute_spline_models | !file.exists(filename)) {
    cat(sprintf("Fitting Bayesian logistic model with splines for Hb-deferral on group %s\n", group))
    
    bayesian_fit <- brm(formula,
                        data = data, #%>% slice_sample(n=10000),
                        family = bernoulli(),
                        file = NULL,
                        control = list(max_treedepth = 15, adapt_delta = 0.99),
                        #refresh = 0,
                        cores = 4,
                        iter = 2000,
                        warmup = 1000
    )
    saveRDS(bayesian_fit, filename)
  } else {
    cat(sprintf("Loading prefitted Bayesian logistic model with splines for Hb-deferral on group %s\n", group))
    bayesian_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(bayesian_fit)))
}

full_spline_input <- tibble(group=setdiff(names(cohort_colors), c("all", "pre_menopausal_female", "post_menopausal_female")),
                         data=full_spline_datas,
                         formula=full_spline_formulas)
full_spline_fits <- pmap_dfr(full_spline_input, fit_full_spline_helper)
full_spline_fits_list <- deframe(full_spline_fits)

```

### 3.5.3. Plotting comparison plots full spline vs. bayes

```{r Helper functions for plotting full spline bayes models, eval=FALSE}
# code from deferral_logistic_and_cox.Rmd

# plot(conditional_smooths(spline_fit, smooths = "s(age)"), ask = FALSE)
# Returns a tibble with columns for variable, x-coordinate, estimate, upper and lower bound
#   effect1__ cond__ estimate__  se__   lower__ upper__ name        value
#   <dbl>     <fct>  <dbl>       <dbl>  <dbl>   <dbl>   <chr>       <dbl>
helper <- function(fit) {
  x <- conditional_smooths(fit)
  # bind_rows(
  #   pivot_longer(x[[1]], cols = days_to_previous_fb),
  #   pivot_longer(x[[2]], cols = age),
  #   pivot_longer(x[[3]], cols = weight)
  #)
  bind_rows(map2(1:length(full_spline_variables), full_spline_variables,
                 function(i, n) pivot_longer(x[[i]], cols = n)))
}

# Extract these from the fit for abline function.
# Returns a tibble with columns for variable name, intercept and slope.
helper2 <- function(fit) {
  t <- as_tibble(fit)
  df <- t %>%
    select(-Intercept) %>%
    rename_with(.cols=everything(), .fn = function(x) str_remove(x, "^b_")) %>%
    select(all_of(full_spline_variables), Intercept) %>%
    summarise(across(everything(), mean)) %>%
    pivot_longer(cols=-Intercept, values_to = "slope") %>%
    rename(intercept = Intercept)
  return(df)
}

# This is for renaming the facet titles
plot_labeller <- function(group){
    case_when(group == "pre_menopausal_female" ~ "pre",
              group == "post_menopausal_female" ~ "post",
              TRUE ~ group)
}
```

```{r Full spline curves and lines, eval=FALSE}
evaluated_full_splines <- map_dfr(full_spline_fits_list, helper, .id="group") %>%
  mutate(group = factor(group))

# For comparison take the slopes for each linear predictor from the earlier models
line_coeffs <- map_dfr(bayesian_fits_list, helper2, .id="group") %>%
  filter(group %in% c("male", "female")) %>%
  #filter(group == "all") %>%
  mutate(group = factor(group)) %>%
  mutate(intercept = 0)  # Don't use these after all for comparability with the splines

```

```{r Plot scaled full splines, eval=FALSE}
g_scaled <- evaluated_full_splines %>%
  ggplot(aes(value, estimate__)) +
  geom_ribbon(mapping=aes(x=value, ymin=lower__, ymax=upper__), fill="lightgray") +
  geom_line(color="blue") +
  geom_abline(mapping=aes(intercept=intercept, slope=slope), data = line_coeffs) +
  labs(title="Hb deferral, scaled", y="s(value)") +
  #lims(y=c(-10, 5)) +
  # facet_grid(group ~ name,
  #            scales = "free",
  #            labeller = labeller(group=plot_labeller))
  ggh4x::facet_grid2(group ~ name,
             scales = "free",
             labeller = labeller(group=plot_labeller),
             independent = TRUE)
if (save_figs) {
  filename <- sprintf("%s/full_splines_scaled.pdf", fig_path)
  ggsave(filename=filename, 
         plot=g_scaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
g_scaled
```

```{r Plot unscaled full splines, eval=FALSE}
  
scaled_evaluated_full_splines <- evaluated_full_splines %>%
  #filter(group == "all") %>%
  inner_join(variable_stats, by=c("group", "name")) %>%
  mutate(value = value * sd + mean)

g_unscaled <- scaled_evaluated_full_splines %>%
  ggplot(aes(value, estimate__)) +
  geom_ribbon(mapping=aes(x=value, ymin=lower__, ymax=upper__), fill="lightgray") +
  geom_line(color="blue") +
  geom_abline(mapping=aes(intercept=intercept, slope=slope),
              data = line_coeffs %>%
                #filter(group != "female") %>%
                left_join(variable_stats, by=c("group", "name")) %>%
                mutate(intercept = -slope*mean/sd, slope = slope / sd)) +
  labs(title="Hb deferral, unscaled", y="s(value)") +
  ggh4x::facet_grid2(rows=vars(group), cols=vars(name), scales = "free", independent = TRUE,
                    labeller = labeller(group=plot_labeller))
  # facet_grid(rows=vars(group), cols=vars(name), scales = "free",
  #                    labeller = labeller(group=plot_labeller))
if (save_figs) {
  filename <- sprintf("%s/full_splines_unscaled.pdf", fig_path)
  ggsave(filename=filename, 
         plot=g_unscaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
}
g_unscaled
```

## 3.6. Bayesian models with splines for age, blood_volume, days_to_previous_fb

### 3.6.1. Define spline variables and formulas for partly spline models

Splines for age, blood_volume, days_to_previous_fb

```{r Define formulas with splines}
#recompute_spline_models <- TRUE

spline_variables <- c("age", "blood_volume", "days_to_previous_fb") # Make these variables use splines

tmp <-as.character(bayes_formula_all)
tmp2 <- sprintf("%s ~ %s", tmp[2], tmp[3]) # Formula converted to a string
spline_formula_all <- as.formula(str_replace_all(tmp2, paste(spline_variables, collapse="|"), "s(\\0)"))
print(spline_formula_all)
	
tmp <- as.character(bayes_formula_male)
tmp2 <- sprintf("%s ~ %s", tmp[2], tmp[3])
spline_formula_male <- as.formula(str_replace_all(tmp2, paste(spline_variables, collapse="|"), "s(\\0)"))
print(spline_formula_male)

tmp <- as.character(bayes_formula_female)
tmp2 <- sprintf("%s ~ %s", tmp[2], tmp[3])
spline_formula_female <- as.formula(str_replace_all(tmp2, paste(spline_variables, collapse="|"), "s(\\0)"))
print(spline_formula_female)

# tmp <- as.character(bayes_formula_pre_menopausal_female)
# tmp2 <- sprintf("%s ~ %s", tmp[2], tmp[3])
# spline_formula_pre_menopausal_female <- as.formula(str_replace_all(tmp2, paste(spline_variables, collapse="|"), 
#                                                                    "s(\\0)"))
# print(spline_formula_pre_menopausal_female)
# 
# tmp <- as.character(bayes_formula_post_menopausal_female)
# tmp2 <- sprintf("%s ~ %s", tmp[2], tmp[3])
# spline_formula_post_menopausal_female <- as.formula(str_replace_all(tmp2, paste(spline_variables, collapse="|"), 
#                                                                     "s(\\0)"))
# print(spline_formula_post_menopausal_female)

```

```{r Spline data and formula lists}
spline_datas <-list(all=data_all, 
                    male=data_male, female=data_female)
                    # pre_menopausal_female=data_pre_menopausal_female,
                    # post_menopausal_female=data_post_menopausal_female)
spline_formulas <- list(all=spline_formula_all,
                        male=spline_formula_male, female=spline_formula_female)
                        # pre_menopausal_female=spline_formula_pre_menopausal_female,
                        # post_menopausal_female=spline_formula_post_menopausal_female)
```

### 3.6.2. Fit models

```{r Fit all Bayesian spline models}
fit_bayesian_spline_helper <- function(group, data, formula) {
  filename <- sprintf("%s/bayesian_spline_fit_%s.rds", base, group)
  if (recompute_spline_models | !file.exists(filename)) {
    bayesian_fit <- brm(formula,
                        data = data, 
                        family = bernoulli(),
                        file = NULL,
                        control = list(max_treedepth = 14), #control = list(max_treedepth=15, adapt_delta=0.99),
                        #refresh = 0,
                        cores = cores, 
                        iter = iterations, #iter = 11000
                        warmup = 500
    )
    saveRDS(bayesian_fit, filename)
  } else {
    cat(sprintf("Loading prefitted Spline model for Hb-deferral on group %s\n", group))
    bayesian_fit <- readRDS(filename)
  }
  return(tibble(group=group, fit=list(bayesian_fit)))
}

bayesian_spline_input <- tibble(group=setdiff(names(cohort_colors), c("pre_menopausal_female", "post_menopausal_female")),
                         data=spline_datas,
                         formula=spline_formulas)
spline_fits <- pmap_dfr(bayesian_spline_input, fit_bayesian_spline_helper)
spline_fits_list <- deframe(spline_fits)

```

```{r Save spline_fits as a list}
filename <- sprintf("%s/spline_fits_list.rds", base)
saveRDS(spline_fits_list, filename)
```

### 3.6.3. Plot unscaled and scaled spline models compared to bayes models

```{r Understanding the spline fit model summary}
# test <- conditional_smooths(spline_fits_list$male)
# summary(test)
# 
# test[[1]] # age
# test[[2]] # blood_volume
# test[[3]] # days_to_previous_fb
```

```{r Plot scaled splines}
#plot(conditional_smooths(spline_fit, smooths = "s(age)"), ask = FALSE)
helper <- function(fit) {
  x <- conditional_smooths(fit)
  bind_rows(
    pivot_longer(x[[1]], cols = age),
    pivot_longer(x[[2]], cols = blood_volume),
    pivot_longer(x[[3]], cols = days_to_previous_fb)
  )
}

# Extract these from the fit for abline function.
helper2 <- function(fit) {
  t <- as_tibble(fit)
  df <- tribble(
    ~name, ~slope, ~intercept,
    "days_to_previous_fb", mean(t$b_days_to_previous_fb), mean(t$b_Intercept),
    "age", mean(t$b_age), mean(t$b_Intercept),
    "blood_volume", mean(t$b_blood_volume), mean(t$b_Intercept)
  )
  return(df)
}

x <- map_dfr(spline_fits_list, helper, .id="group")

# This doesn't work with labeller as it assumes the function converts character vectors to character vectors.
# So, it doesn't operate on factors.
plot_labeller <- function(group){
  group <- case_when(group == "pre_menopausal_female" ~ "pre",
                     group == "post_menopausal_female" ~ "post",
                     TRUE ~ group)
  factor(group, levels=c("all", "female", "male", "pre", "post"))
}

plot_labeller2 <- function(group){
  fct_recode(group, pre = "pre_menopausal_female", post="post_menopausal_female")
}


line_coeffs <- map_dfr(bayesian_fits_list, helper2, .id="group") %>%
  #filter(!group %in% c("all", "female")) %>%
  mutate(group = plot_labeller(group)) %>%
  mutate(intercept = 0)  # Don't use these after all for comparability with the splines

g_scaled <- x %>% 
  mutate(group = factor(group, levels=c("all", "male", "female", "pre_menopausal_female", 
                                        "post_menopausal_female"))) %>%
  mutate(group = plot_labeller(group)) %>%
  ggplot(aes(value, estimate__)) + 
  geom_ribbon(mapping=aes(x=value, ymin=lower__, ymax=upper__), fill="lightgray") + 
  geom_line(color="blue") + 
  geom_abline(mapping=aes(intercept=intercept, slope=slope), data = line_coeffs) +
  labs(title="Linearity of the spline variables, scaled splines", y="s(value)") +
  #lims(y=c(-10, 5)) +
  ggh4x::facet_grid2(rows=vars(group), cols=vars(name), scales = "free", independent = TRUE, 
                     labeller = labeller(group=plot_labeller)
                     )
if (save_figs) {
  filename <- sprintf("%s/splines_scaled.pdf", fig_path)
  ggsave(filename=filename, 
         plot=g_scaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
  
  filename <- sprintf("%s/splines_scaled.png", fig_path)
  ggsave(filename=filename, 
         plot=g_scaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="png")
}

g_scaled
```

```{r Plot unscaled splines}
variable_stats2 <- variable_stats %>%
  mutate(group = case_when(
    group == "pre_menopausal_female" ~ "pre",
    group == "post_menopausal_female" ~ "post",
    TRUE  ~ group
  ))

unscaled_line_coeffs <- line_coeffs %>% 
                left_join(variable_stats2, by=c("group", "name")) %>% 
                mutate(intercept = -slope*mean/sd, slope = slope / sd)

g_unscaled <- x %>% inner_join(variable_stats, by=c("group", "name")) %>%
  mutate(value = value * sd + mean) %>%
  mutate(group = plot_labeller(group)) %>%
  ggplot(aes(value, estimate__)) + 
  geom_ribbon(mapping=aes(x=value, ymin=lower__, ymax=upper__), fill="lightgray") + 
  geom_line(color="blue") + 
  geom_abline(mapping=aes(intercept=intercept, slope=slope), 
              data = unscaled_line_coeffs) +
  labs(title="Linearity of the spline variables, unscaled splines", y="s(value)") +
  ggh4x::facet_grid2(rows=vars(group), cols=vars(name), scales = "free", independent = TRUE,
                    labeller = labeller(group=plot_labeller)
                     )
if (save_figs) {
  filename <- sprintf("%s/splines_unscaled.pdf", fig_path)
  ggsave(filename=filename, 
         plot=g_unscaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
  
   filename <- sprintf("%s/splines_unscaled.png", fig_path)
  ggsave(filename=filename, 
         plot=g_unscaled, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="png")
}
g_unscaled
```

### 3.6.4. Diagnostics

#### Trace

```{r Trace plots spline, fig.dim=c(12,12)}
helper <- function(group, fit) {
  bp <- bayesplot::mcmc_trace(as_draws_array(fit, inc_warmup = TRUE), n_warmup = iterations/2) +
    ggtitle(sprintf("Trace for BayesLogRSpline for group: %s", group))
  if (save_figs) {
    filename <- sprintf("%s/spline_traces_%s.pdf", fig_path, group)
    ggsave(filename=filename, plot=bp, width=380, height=300, units="mm", dpi=300, scale=1.0, device="pdf")
    
    filename <- sprintf("%s/spline_traces_%s.png", fig_path, group)
    ggsave(filename=filename, plot=bp, width=380, height=300, units="mm", dpi=300, scale=1.0, device="png")
  }
  bp
}

pmap(spline_fits, helper)
```

```{r}
draws_array <- as_draws_array(spline_fits_list$all)
colnames(as_draws_df(draws_array))
```

```{r}
# helper <- function(group, fit) {
#   # Convert fit to array and include warmup
#   draws_array <- as_draws_array(fit, inc_warmup = TRUE)
#   n_col <- ncol(as_draws_df(draws_array))
#   
#   original_labels <- colnames(as_draws_df(draws_array))[1:(n_col-3)]
#   
#   new_labels <- c("b_Intercept" = "b_Intercept", "b_previous_Hb" = "Previous Hb", "b_smokingTRUE" = "Smoking",
#                   "b_age" = "Age", "b_blood_volume" = "Blood volume", "b_year" = "Year", 
#                   "b_warm_seasonTRUE" = "Warm Season",
#                   "b_days_to_previous_fb" = "Days to previous fbd", "b_recent_donations" = "Recent donations",
#                   "b_recent_deferrals" = "Recent deferral", "b_snp_1_113834946" = "SNP 1:113834946", 
#                   "b_snp_1_169549811" = "SNP 1:169549811", "b_snp_4_25970243" = "SNP 4:25970243", 
#                   "b_snp_6_25857692" = "SNP 6:6_25857692", "b_snp_6_32617727" = "SNP 6:32617727",
#                   "b_snp_6_32658525" = "SNP 6:32658525", "b_snp_6_68206710" = "SNP 6:68206710",
#                   "b_snp_7_75844637" = "SNP 7:75844637", "b_snp_8_10785723" = "SNP 8:10785723",
#                   "b_snp_8_23520397" = "SNP 8:23520397", "b_snp_8_75503352" = "SNP 8:75503352",
#                   "b_snp_9_133271182" = "SNP 9:133271182", "b_snp_10_63174788" = "SNP 10:63174788",
#                   "b_snp_11_5226799" = "SNP 11:5226799", "b_snp_12_6030341" = "SNP 12:6030341",
#                   "b_snp_14_33938877" = "SNP 14:33938877", "b_snp_15_45099877" = "SNP 15:45099877",
#                   "b_snp_17_58358769" = "SNP 17:58358769", "b_snp_20_35186730" = "SNP 20:35186730",
#                   "b_snp_22_29795932" = "SNP 22:29795932", "b_snp_22_37066896" = "SNP 22:37066896",
#                   "b_femaleTRUE" = "Female", "b_smokingTRUE:femaleTRUE" = "Smoking:Female",
#                   "b_snp_22_37066896:grouppost_menopausal_female" = "SNP 22:37066896:Post Menopausal Female",
#                   "b_snp_22_37066896:grouppre_menopausal_female" = "SNP 22:37066896:Pre Menopausal Female",
#                   "b_snp_1_169549811:grouppost_menopausal_female" = "SNP 1:169549811:Post Menopausal Female",
#                   "b_snp_1_169549811:grouppre_menopausal_female" =  "SNP 1:169549811:Pre Menopausal Female",
#                   "bs_sage_1", "bs_sblood_volume_1" , "bs_sdays_to_previous_fb_1", "sds_sage_1",
#                   "sds_sblood_volume_1", "sds_sdays_to_previous_fb_1", "s_sage_1[1]",
#                   "s_sage_1[2]", "s_sage_1[3]", "s_sage_1[4]", "s_sage_1[5]", "s_sage_1[6]",              
#                   "s_sage_1[7]", "s_sage_1[8]", "s_sblood_volume_1[1]", "s_sblood_volume_1[2]",
#                   "s_sblood_volume_1[3]", "s_sblood_volume_1[4]", "s_sblood_volume_1[5]", "s_sblood_volume_1[6]",
#                   "s_sblood_volume_1[7]", "s_sblood_volume_1[8]", "s_sdays_to_previous_fb_1[1]",
#                   "s_sdays_to_previous_fb_1[2]",
#                   "s_sdays_to_previous_fb_1[3]", "s_sdays_to_previous_fb_1[4]", "s_sdays_to_previous_fb_1[5]",
#                   "s_sdays_to_previous_fb_1[6]", "s_sdays_to_previous_fb_1[7]", "s_sdays_to_previous_fb_1[8]",
#                   "Intercept" = "Intercept", "lprior" = "lprior", "lp__")
#   
#   # Create trace plot with customization
#   bp <- mcmc_trace(draws_array, pars = original_labels, n_warmup = iterations / 2) +
#     ggtitle(sprintf("Trace for BayesLogRSpline for group: %s", group)) +
#     facet_wrap(~parameter, scales = "free_y", ncol = 3, 
#                labeller = labeller(parameter = new_labels)) +  # Facet wrap for variables
#     scale_color_manual(values = c(c("#0072B2", "#E69F00", "#009E73", "#CC79A7"))) +  # Color coding for chains
#     theme_minimal() +  # Minimal theme for better readability
#     theme(legend.position = "right", # Position legend at the bottom
#           plot.title = element_text(size = 15),  # Increase title size
#           strip.text = element_text(size = 10),
#           legend.title = element_text(size = 15),
#           legend.text = element_text(size = 15),# Increase legend text size
#           legend.key.size = unit(3, "lines")) +  # Increase legend key size
#     guides(color = guide_legend(override.aes = list(size = 2)))  # Thicker lines in legend
#   
#   
#   # Save figures if required
#   if (save_figs) {
#     pdf_filename <- sprintf("%s/spline_traces_%s.pdf", fig_path, group)
#     png_filename <- sprintf("%s/spline_traces_%s.png", fig_path, group)
#     
#     ggsave(filename = pdf_filename, plot = bp, width = 210, height = 297, units = "mm", dpi = 300, device = "pdf")
#     ggsave(filename = png_filename, plot = bp, width = 210, height = 297, units = "mm", dpi = 300, device = "png")
#   }
#   
#   return(bp)
# }
# 
# pmap(spline_fits, helper)
```

```{r}
helper <- function(group, fit) {
  # Convert fit to array and include warmup
  draws_array <- as_draws_array(fit, inc_warmup = TRUE)
  n_col <- ncol(as_draws_df(draws_array))
  
  original_labels <- colnames(as_draws_df(draws_array))[1:(n_col-3)]
  
  new_labels <- c("b_Intercept" = "b_Intercept", "b_previous_Hb" = "Previous Hb", "b_smokingTRUE" = "Smoking",
                  "b_age" = "Age", "b_blood_volume" = "Blood volume", "b_year" = "Year", 
                  "b_warm_seasonTRUE" = "Warm Season",
                  "b_days_to_previous_fb" = "Days to previous fbd", "b_recent_donations" = "Recent donations",
                  "b_recent_deferrals" = "Recent deferral", "b_snp_1_113834946" = "SNP 1:113834946", 
                  "b_snp_1_169549811" = "SNP 1:169549811", "b_snp_4_25970243" = "SNP 4:25970243", 
                  "b_snp_6_25857692" = "SNP 6:6_25857692", "b_snp_6_32617727" = "SNP 6:32617727",
                  "b_snp_6_32658525" = "SNP 6:32658525", "b_snp_6_68206710" = "SNP 6:68206710",
                  "b_snp_7_75844637" = "SNP 7:75844637", "b_snp_8_10785723" = "SNP 8:10785723",
                  "b_snp_8_23520397" = "SNP 8:23520397", "b_snp_8_75503352" = "SNP 8:75503352",
                  "b_snp_9_133271182" = "SNP 9:133271182", "b_snp_10_63174788" = "SNP 10:63174788",
                  "b_snp_11_5226799" = "SNP 11:5226799", "b_snp_12_6030341" = "SNP 12:6030341",
                  "b_snp_14_33938877" = "SNP 14:33938877", "b_snp_15_45099877" = "SNP 15:45099877",
                  "b_snp_17_58358769" = "SNP 17:58358769", "b_snp_20_35186730" = "SNP 20:35186730",
                  "b_snp_22_29795932" = "SNP 22:29795932", "b_snp_22_37066896" = "SNP 22:37066896",
                  "b_femaleTRUE" = "Female", "b_smokingTRUE:femaleTRUE" = "Smoking:Female",
                  "b_snp_22_37066896:grouppost_menopausal_female" = "SNP 22:37066896:Post Menopausal Female",
                  "b_snp_22_37066896:grouppre_menopausal_female" = "SNP 22:37066896:Pre Menopausal Female",
                  "b_snp_1_169549811:grouppost_menopausal_female" = "SNP 1:169549811:Post Menopausal Female",
                  "b_snp_1_169549811:grouppre_menopausal_female" =  "SNP 1:169549811:Pre Menopausal Female",
                  "bs_sage_1", "bs_sblood_volume_1" , "bs_sdays_to_previous_fb_1", "sds_sage_1",
                  "sds_sblood_volume_1", "sds_sdays_to_previous_fb_1", "s_sage_1[1]",
                  "s_sage_1[2]", "s_sage_1[3]", "s_sage_1[4]", "s_sage_1[5]", "s_sage_1[6]",              
                  "s_sage_1[7]", "s_sage_1[8]", "s_sblood_volume_1[1]", "s_sblood_volume_1[2]",
                  "s_sblood_volume_1[3]", "s_sblood_volume_1[4]", "s_sblood_volume_1[5]", "s_sblood_volume_1[6]",
                  "s_sblood_volume_1[7]", "s_sblood_volume_1[8]", "s_sdays_to_previous_fb_1[1]",
                  "s_sdays_to_previous_fb_1[2]",
                  "s_sdays_to_previous_fb_1[3]", "s_sdays_to_previous_fb_1[4]", "s_sdays_to_previous_fb_1[5]",
                  "s_sdays_to_previous_fb_1[6]", "s_sdays_to_previous_fb_1[7]", "s_sdays_to_previous_fb_1[8]",
                  "Intercept" = "Intercept", "lprior" = "lprior", "lp__")
  
  # Split parameters into two groups
  params_group1 <- original_labels[1:35]
  params_group2 <- original_labels[36:length(original_labels)]
  
  # Create trace plots for each group
  bp1 <- mcmc_trace(draws_array, pars = params_group1, n_warmup = iterations / 2) +
    ggtitle(sprintf("Trace for BayesLogRSpline for group: %s 1", group)) +
    facet_wrap(~parameter, scales = "free_y", ncol = 3, 
               labeller = labeller(parameter = new_labels)) +
    scale_color_manual(values = c("#0072B2", "#E69F00", "#009E73", "#CC79A7")) +
    theme_minimal() +
    theme(legend.position = "right",
          plot.title = element_text(size = 15),
          strip.text = element_text(size = 10),
          legend.title = element_text(size = 15),
          legend.text = element_text(size = 15),
          legend.key.size = unit(3, "lines")) +
    guides(color = guide_legend(override.aes = list(size = 2)))
  
  bp2 <- mcmc_trace(draws_array, pars = params_group2, n_warmup = iterations / 2) +
    ggtitle(sprintf("Trace for BayesLogR for group: %s 2", group)) +
    facet_wrap(~parameter, scales = "free_y", ncol = 3, 
               labeller = labeller(parameter = new_labels)) +
    scale_color_manual(values = c("#0072B2", "#E69F00", "#009E73", "#CC79A7")) +
    theme_minimal() +
    theme(legend.position = "right",
          plot.title = element_text(size = 15),
          strip.text = element_text(size = 10),
          legend.title = element_text(size = 15),
          legend.text = element_text(size = 15),
          legend.key.size = unit(3, "lines")) +
    guides(color = guide_legend(override.aes = list(size = 2)))
  
  # Save figures if required
  if (save_figs) {
    pdf_filename1 <- sprintf("%s/spline_traces_%s_page1.pdf", fig_path, group)
    pdf_filename2 <- sprintf("%s/spline_traces_%s_page2.pdf", fig_path, group)
    png_filename1 <- sprintf("%s/spline_traces_%s_page1.png", fig_path, group)
    png_filename2 <- sprintf("%s/spline_traces_%s_page2.png", fig_path, group)
    
    ggsave(filename = pdf_filename1, plot = bp1, width = 210, height = 297, units = "mm", dpi = 300, device = "pdf")
    ggsave(filename = pdf_filename2, plot = bp2, width = 210, height = 297, units = "mm", dpi = 300, device = "pdf")
    ggsave(filename = png_filename1, plot = bp1, width = 210, height = 297, units = "mm", dpi = 300, device = "png")
    ggsave(filename = png_filename2, plot = bp2, width = 210, height = 297, units = "mm", dpi = 300, device = "png")
  }
  
  return(list(bp1, bp2))
}

pmap(spline_fits, helper)
```



#### Auto-correlation

```{r Autocorrelation plots spline, fig.dim=c(10,15)}
helper <- function(group, fit) {
  g <- mcmc_plot(fit, type = "acf_bar") + labs(title=group)
  if (save_figs) {
    filename <- sprintf("%s/spline_auto_correlations_%s.pdf", fig_path, group)
    ggsave(filename=filename, plot=g, width=800, height=300, units="mm", dpi=300, scale=1.0, device="pdf")
  }
  g
}
pmap(spline_fits, helper)
```

Check Rhats to see if we converged.

```{r Plot Rhats spline}
helper <- function(group, fit) {
  g <- mcmc_plot(fit, type = "rhat") + labs(title= sprintf("Rhats for BayesLogRSpline for group: %s", group))
  if (save_figs) {
    filename <- sprintf("%s/spline_rhats_%s.pdf", fig_path, group)
    ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="pdf")
    
    filename <- sprintf("%s/spline_rhats_%s.png", fig_path, group)
    ggsave(filename=filename,  plot=g, width = 180,  height = 120, units="mm", dpi=300, scale=1.0, device="png")
  }
  g
}

pmap(spline_fits, helper)
```


### 3.4.5. Effect sizes

```{r Spline cis}
filename <- sprintf("%s/spline_cis.tsv", table_path)
if (recompute | !file.exists(filename)) {
  spline_cis <- pretty_bayes_intervals(spline_fits_list)
  write_tsv(spline_cis, file=filename)
} else {
  spline_cis <- read_tsv(filename)
  cat("Loaded precomputed spline_cis.")
}
```

```{r Forest plot linear vs spline, fig.dim=c(10,12)}
spline_comparison_cis <- bind_rows(linear=bayes_cis, spline=spline_cis, .id="Dependency")

g <- spline_comparison_cis %>%
  mutate(Dependency = fct_recode(Dependency, `non-linear`="spline")) %>%
  mutate(Pretty = fct_relevel(Pretty, function(levels) str_sort(levels, numeric=TRUE))) %>%
  filter(group %in% c("all", "female", "male")) %>%
  mutate(group = factor(group, levels=c("all", "female", "male"))) %>%
  mutate(across(c(Dependency, Pretty), fct_rev)) %>%
  mutate(hollow_dependency=factor(if_else(low<=1 & high>=1, NA_character_, as.character(Dependency)),
                             levels=levels(Dependency))) %>%
  ggplot(aes(x=estimate, xmin=low, xmax=high, y=term, # y=Pretty for pretty labs
             color=Dependency, fill=hollow_dependency)) + 
  geom_vline(aes(xintercept=1), color="gray", 
             #size=1
             linewidth=1
             ) +
  geom_stripes(bayes_cis %>% filter(term != "femaleTRUE"), Pretty) +
  ggstance::geom_linerangeh(position=position_dodge(width=1), 
                            size=0.2
                            #linewidth=0.2
                            ) + 
  geom_point(#aes(), 
             #fill=NA, 
             shape=21,
             size=1.5,
             position=position_dodge(width=1)) +
  labs(#title = "Linear vs spline dependency", 
       x="Odds ratio", y="Standardized variables") + 
  #scale_colour_manual(values = cohort_colors) +
  facet_wrap(~group) +
  scale_color_discrete(breaks = c("linear", "non-linear"), na.value = "NA") +
  scale_fill_discrete(guide="none", na.value = "NA") +
  # scale_colour_manual(values = cohort_colors[names(cohort_colors) != "all"],
  #                     labels = cohort_names[names(cohort_names) != "all"], na.value = NA, drop=FALSE) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  coord_cartesian(xlim = c(0.0001, 12)) +
  scale_x_log10() +
  scale_y_discrete() + # This is important. Solves the problem with position_dodge2 
                       # and the order of rect and pointrange geoms!!!
                       # Otherwise following error results: Error: Discrete value supplied to continuous scale
  theme(legend.position="bottom",
        legend.direction = "horizontal")

if (save_figs) {
  filename <- sprintf("%s/linear_vs_spline.pdf", fig_path)
  ggsave(filename=filename, plot=g, width = 200,  height=300, units="mm", dpi=300, scale=1.0, device="pdf")
}

g

```


## 3.6. Combine confidence intervals from the three methods on full data (NOT needed for this project!)
- Compare confidence intervals of coefficients from two frequentist and one Bayesian method

- I don't have two frequentist methods. I have one linear frequentist method. 
(Jarkko had used self_made_cis and mass_cis for calculating the confidence intervals for the freq method,
I used only broom::tidy(fit, conf.int = TRUE, exponentiate = TRUE) to calculated cis for freq method.
- Two bayes methods: linear and non linear using splines.


## 3.7. Odds ratios of high genetic risk versus low genetic risk (NOT needed for this project!)
I don't have prs yet so I cannot do this.


# 4. Survival analysis
## 4.1. Scaling data for Cox models

```{r Define cox variables}
cox_variables <- c("blood_volume",
                   "previous_Hb",
                   "smoking",
                   snp_descript$Variable)
```

```{r Unscaled datas for survival model}
unscaled_sur_male <- cox_train %>% filter(group == "male")
unscaled_sur_female <- cox_train %>% filter(group != "male")
# unscaled_sur_pre_menopausal_female <- data_cox %>% filter(group == "pre_menopausal_female")
# unscaled_sur_post_menopausal_female <- data_cox %>% filter(group == "post_menopausal_female")
```

```{r Scale for Cox models}
scale_helper <- function(df) {
  df %>% mutate(across(where(is.numeric) & !any_of(c("age", "cox_status")) & ! starts_with("snp_"), myscale))
}

scaled_sur <- scale_helper(cox_train)
scaled_sur_male <- scale_helper(unscaled_sur_male) 
scaled_sur_female <- scale_helper(unscaled_sur_female)
# scaled_sur_pre_menopausal_female <- scale_helper(unscaled_sur_pre_menopausal_female)
# scaled_sur_post_menopausal_female <- scale_helper(unscaled_sur_post_menopausal_female)
```

Jarkko: Check the male data. Because the data is sorted by time, some distributions look very skewed.

Krista: Just to make sure there is nothing odd going on, I check the same thing also.

```{r}
tmp <- scaled_sur_male %>% 
  select(all_of(cox_model_variables)) %>%
  #select(-snp_1_169549811) %>% # doesn't cause separation here?
  #select(-c(recent_deferrals, consecutive_deferrals)) %>%
  drop_na() %>% 
  mutate(smoking=as.numeric(smoking)) %>% 
  select(where(is.numeric)) %>%
  mutate(donors = ifelse(row_number() <= 1700, "old", "new")) %>%
  group_by(donors) %>% slice_sample(n=1700) %>% ungroup()

tmp %>%
#  pivot_longer(cols = everything()) %>% 
  pivot_longer(cols = -donors) %>% 
  ggplot(aes(x=value, fill=donors)) + geom_histogram(position = "dodge") + 
  facet_wrap(~name, scales = "free")
```

Krista: I think all looks okay.


## 4.2. Kaplan-Meier curves


```{r}
km_fit <- survival::survfit(Surv(age, cox_status) ~ 1, data=cox_train)
autoplot(km_fit) + labs(x="Age", y="Survival from Hb deferral", title = "From cox_train data")
ggsurvplot(km_fit, palette = "#2E9FDF", conf.int = TRUE, risk.table = TRUE, risk.table.y.text.col=TRUE,
           title = "From cox_train data")
```

```{r Stratify by sex}
ggsurvplot(survival::survfit(Surv(age, cox_status) ~ female, data=cox_train), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3,
           title = "From cox_train data")
```

```{r Stratify by RNF43 snip male}
helper <- function(fun) {
  g <- ggsurvplot(survival::survfit(Surv(age, cox_status) ~ snp_17_58358769, data=unscaled_sur_male), 
             fun=fun, conf.int = TRUE,
             title = "Statify by SNP 17:58358769 male") 
             #risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
  g
}
g1 <- helper("event")
g2 <- helper(NULL)  # no transformation means the normal survival curve
g3 <- helper("cumhaz")

#arrange_ggsurvplots(list(g1, g2, g3), ncol=1, nrow=3)
print(g1$plot)
print(g2$plot)
print(g3$plot)
```

```{r Stratify by RNF43 snip female}
ggsurvplot(survival::survfit(Surv(age, cox_status) ~ snp_17_58358769, data=unscaled_sur_female), conf.int = TRUE, 
           risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3,
           title = "Statify by SNP 17:58358769 female")
```

```{r Stratify by RNF43 snip premenopausal females}
# ggsurvplot(survival::survfit(Surv(age, cox_status) ~ snp_17_58358769, data=unscaled_sur_pre_menopausal_female), conf.int = TRUE, 
#            risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r Stratify by RNF43 snip postmenopausal females}
# ggsurvplot(survival::survfit(Surv(age, surv_status) ~ snp_17_58358769,
#                              data=unscaled_sur_post_menopausal_female), 
#            conf.int = TRUE, 
#            risk.table = TRUE, risk.table.y.text.col=TRUE, risk.table.height = 0.3)
```

```{r}
# helper <- function(variable) {
#   force(variable)
#   form <- sprintf("Surv(age, surv_status) ~ %s", variable)
#   print(form)
#   form <- as.formula(form)
#   
#   # Note! Below we need to use survminer::surv_fit instead of survival::survfit
#   # To fix the following error https://github.com/kassambara/survminer/issues/252
#   
#   fit <- survminer::surv_fit(form, data=data_survival)
#   num_strata <- length(unique(data_survival[[variable]]))
#   legend_labels <- as.character(0:(num_strata - 1))
#   
#   g <- ggsurvplot(
#     fit,
#     legend = "right",
#     legend.labs = legend_labels,
#     legend.title = "Dosage",
#     censor = FALSE,
#     conf.int = TRUE) 
#   g + labs(title=variable, y="")
# }
# G <- map(snp_variables, helper)
# 
# g <- G[[1]]$plot / G[[2]]$plot / G[[3]]$plot / G[[4]]$plot + plot_layout(guides = 'collect') + #plost only the first 4 snps
#   labs(y="Survival probability")
# 
# if (save_figs) {
#   #filename <- sprintf("%s/pdf/deferral_kaplan_meyer.pdf", result_base)
#   filename <- sprintf("%s/old_deferral_kaplan_meyer.pdf", fig_path)
#   ggsave(filename=filename, g, width = 240,  height=240, units="mm", dpi=300, scale=1.0, device="pdf")
# }
# 
# g

```

```{r Better KM plots, message=FALSE}
#library(pammtools)
kaplan_meyer_helper <- function(variable, sur, smooth=FALSE) {
  smooth_helper <- function(df, key) {
    min_time <- min(df$time)
    max_time <- max(df$time)
    result <- tibble(time=seq(min_time, max_time, length.out = 100))
    for (variable2 in c("surv", "low", "high")) {
      form <- sprintf("%s ~ s(time, bs='cs')", variable2)
      form <- as.formula(form)
      
      gm <- mgcv::gam(form, data=df)
      
      result <- result %>% mutate({{variable2}} := as.vector(predict(gm, newdata=result)))
    }
    result
  }
  
  force(variable)
  form <- sprintf("Surv(age, cox_status) ~ %s", variable)
  #print(form)
  form <- as.formula(form)
  res <- survminer::surv_fit(form, data=sur)
  #print(res$strata)
  df <- tibble(time=res$time, surv=res$surv, low=res$lower, high=res$upper,
               Dosage=factor(rep(0:(length(res$strata)-1), res$strata)),
               variable = variable)
  if (smooth) {
    df <- df %>% 
      group_by(Dosage, variable) %>%
      filter(n() > 15) %>%
      group_modify(smooth_helper) %>%
      ungroup() %>%
      mutate()
  }
  df
}

kaplan_meyer <- function(sur, smooth=FALSE) {
  res <- map_dfr(snp_variables, function(variable) kaplan_meyer_helper(variable, sur, smooth)) %>%
    mutate(variable = factor(variable, snp_variables)) %>%
    drop_na()
  res  
}

plot_kaplan_meier <- function(data, smooth_data, pretty_snips, save_figs=FALSE, fig_path='.') {
  variables <- unique(data$variable)
  num_vars <- length(variables)
  num_pages <- ceiling(num_vars / 4)
  
  for (page in 1:num_pages) {
    start_idx <- (page - 1) * 4 + 1
    end_idx <- min(start_idx + 3, num_vars)
    vars_to_plot <- variables[start_idx:end_idx]
    
    g <- data %>% 
      filter(variable %in% vars_to_plot) %>%
      ggplot(aes(time, surv, color=Dosage, ymin=low, ymax=high, fill=Dosage)) + 
      pammtools::geom_stepribbon(alpha=0.2, color=NA) +
      geom_step() +
      facet_wrap(~ variable, labeller=as_labeller(pretty_snips), ncol=2) +
      labs(x="Age [years]", y="Survival")
    
    smoothed_g <- smooth_data %>% filter(variable %in% vars_to_plot) %>%
      ggplot(aes(time, surv, color=Dosage, ymin=low, ymax=high, fill=Dosage)) + 
      geom_ribbon(alpha=0.2, color=NA) +
      geom_line() +
      facet_wrap(~ variable, labeller=as_labeller(pretty_snips), ncol=2) +
      labs(x="Age [years]", y="Survival")
    
    print(g)
    # print(smoothed_g) # smoothed curves are not what we want for now
    
    if (save_figs) {
      filename <- sprintf("%s/deferral_kaplan_meyer_page_%d.pdf", fig_path, page)
      ggsave(filename=filename, g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
      filename <- sprintf("%s/smoothed_deferral_kaplan_meyer_page_%d.pdf", fig_path, page)
      ggsave(filename=filename, smoothed_g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
    }
    
  }
  
  # combine pdfs
  pdf_files <- paste0(fig_path, sprintf("/deferral_kaplan_meyer_page_%d.pdf", 1:num_pages))
  qpdf::pdf_combine(input = pdf_files, output = paste0(fig_path, "/deferral_kaplan_meyer_combined.pdf"))
  
  pdf_files <- paste0(fig_path, sprintf("/smoothed_deferral_kaplan_meyer_page_%d.pdf", 1:num_pages))
  qpdf::pdf_combine(input = pdf_files, output = paste0(fig_path, "/smoothed_deferral_kaplan_meyer_combined.pdf"))
}

pretty_snips <- descript %>% filter(str_starts(Variable, "snp")) %>% select(Variable, Pretty) %>% deframe()
res <- kaplan_meyer(data_cox)
smoothed_res <- kaplan_meyer(data_cox, smooth=TRUE)

plot_kaplan_meier(res, smoothed_res, pretty_snips, save_figs=TRUE, fig_path=fig_path)

```

Separate by sex.

```{r Smooth Kaplan-Meier separated by sex}

plot_kaplan_meier_sex <- function(sex, smooth_data, pretty_snips, save_figs=FALSE, fig_path='.') {
  variables <- unique(smooth_data$variable)
  num_vars <- length(variables)
  num_pages <- ceiling(num_vars / 4)
  
  for (page in 1:num_pages) {
    start_idx <- (page - 1) * 4 + 1
    end_idx <- min(start_idx + 3, num_vars)
    vars_to_plot <- variables[start_idx:end_idx]
    
    smoothed_g <- smooth_data %>% filter(variable %in% vars_to_plot) %>%
      ggplot(aes(time, surv, color=Dosage, ymin=low, ymax=high, fill=Dosage)) + 
      geom_ribbon(alpha=0.2, color=NA) +
      geom_line() +
      facet_wrap(~ variable, labeller=as_labeller(pretty_snips), ncol=2) +
      labs(x="Time", y="Survival", title = toTitleCase(sex))
    
    print(smoothed_g)
    
    if (save_figs) {
      filename <- paste0(fig_path, sprintf("/%s_deferral_kaplan_meyer_page_%d.pdf", sex, page))
      ggsave(filename=filename, smoothed_g, width = 180,  height=180, units="mm", dpi=300, scale=1.0, device="pdf")
    }
    
  }
  
  # combine pdfs
  pdf_files <- paste0(fig_path, sprintf("/%s_deferral_kaplan_meyer_page_%d.pdf", sex, 1:num_pages))
  qpdf::pdf_combine(input = pdf_files, output = paste0(fig_path, sprintf("/%s_deferral_kaplan_meyer_combined.pdf", sex)))
}

# Male
male_smoothed_res <- kaplan_meyer(unscaled_sur_male, smooth=FALSE) # SMOOTHED ONES WERE NOT IDEAL in our case!
plot_kaplan_meier_sex(sex="male", smooth_data=male_smoothed_res, pretty_snips, save_figs=TRUE, fig_path=fig_path)

# Female
female_smoothed_res <- kaplan_meyer(unscaled_sur_female, smooth=FALSE) # SMOOTHED ONES WERE NOT IDEAL in our case!
plot_kaplan_meier_sex(sex="female", smooth_data=female_smoothed_res, pretty_snips, save_figs=TRUE, fig_path=fig_path)

```



## 4.3. Cox regression

### 4.3.1 Define formulas

```{r Define formulas}

# there wasn't enough data for these variables after restricting data
cox_variables <- setdiff(cox_variables,
                         c("snp_6_21989753", "snp_6_22583313", "snp_6_23835557"))

cox_formula_all <- as.formula(sprintf("Surv(age, cox_status) ~ %s", 
                                      paste(c(cox_variables, "female", interactions), collapse=" + ")))
print(cox_formula_all)

cox_formula_male <- as.formula(sprintf("Surv(age, cox_status) ~ %s", 
                                       paste(setdiff(cox_variables,
                                                     c("snp_6_68206710", "snp_11_5226799")), collapse=" + ")))
print(cox_formula_male)

cox_formula_female <- as.formula(sprintf("Surv(age, cox_status) ~ %s", paste(c(cox_variables, "group:snp_22_37066896",
                                                                               "snp_1_169549811:group"), collapse=" + ")))
print(cox_formula_female)

cox_formula_pre_menopausal_female <- as.formula(sprintf("Surv(age, cox_status) ~ %s", 
                                                        paste(setdiff(cox_variables,
                                                                      "snp_6_22583313"), collapse=" + ")))
cox_formula_post_menopausal_female <- as.formula(sprintf("Surv(age, cox_status) ~ %s", 
                                                         paste(setdiff(cox_variables,
                                                                       c("snp_6_21989753", "snp_6_22583313",
                                                                         "snp_6_23835557", "snp_7_75844637",
                                                                         "snp_11_5226799", "snp_15_45099877")),
                                                               collapse=" + ")))
# print(cox_formula_pre_menopausal_female)
# print(cox_formula_post_menopausal_female)
```

### 4.3.2. Fit models

```{r Fit Cox models}
#recompute_cox <- FALSE
filename <- sprintf("%s/cox_fits.rds", base)
if(recompute_cox | !file.exists(filename)) {
  cox_fit_all    <- survival::coxph(cox_formula_all, data=scaled_sur)
  cox_fit_male   <- survival::coxph(cox_formula_male, data=scaled_sur_male)
  cox_fit_female <- survival::coxph(cox_formula_female, data=scaled_sur_female)
  # cox_fit_pre_menopausal_female  <- survival::coxph(cox_formula_pre_menopausal_female, 
  #                                                   data=scaled_sur_pre_menopausal_female)
  # cox_fit_post_menopausal_female <- survival::coxph(cox_formula_post_menopausal_female, 
  #                                                   data=scaled_sur_post_menopausal_female)
  cox_fits_list <- list(all=cox_fit_all, male=cox_fit_male, female=cox_fit_female)
                     # pre_menopausal_female=cox_fit_pre_menopausal_female,
                     # post_menopausal_female=cox_fit_post_menopausal_female)
  saveRDS(cox_fits_list, filename)
} else {
  cox_fits_list <- readRDS(filename)
  cat("Loaded prefitted cox models into cox_fits_list.")
}

```

```{r Saving separate cox fits}
filename <- sprintf("%s/cox_fit_%s.rds", base, "all")
saveRDS(cox_fits_list$all, filename)

filename <- sprintf("%s/cox_fit_%s.rds", base, "male")
saveRDS(cox_fits_list$male, filename)

filename <- sprintf("%s/cox_fit_%s.rds", base, "female")
saveRDS(cox_fits_list$female, filename)
```

```{r}
g <- survminer::ggsurvplot(survfit(cox_fits_list$male), scaled_sur_male, risk.table = TRUE,
                           title = "Cox fit male")
g
```

Jarkko: Below, on the left are the Kaplan-Meier curves and on the right the Cox proportional 
hazards model. For each model the event, survival and cumulative hazard curves are shown. 
This is for male data. Effect of snp_17_58358769 is illustrated. On the right, the model forces
the proportional hazard assumption to hold.

```{r}
# Keep other variables at zero and vary the variable snp_17_58358769
row1 <- as_tibble_row(set_names(rep(0, length(cox_variables)), cox_variables))
params <- bind_rows(row1, row1 %>% mutate(snp_17_58358769=1)) %>% 
  mutate(smoking = as.factor(smoking==1))
print(params)

helper <- function(fun) {
  #survminer::ggsurvplot(survfit(cox_fit_male, newdata=params), scaled_sur_male, risk.table = TRUE)
  sf <- survfit(cox_fits_list$male, data=scaled_sur_male)
  df <- as.data.frame(params)
  g <- survminer::ggsurvplot(survfit(cox_fits_list$male, newdata=df), 
                             data=df, risk.table = FALSE, fun=fun)
  g
}

g4 <- helper("event")
g5 <- helper(NULL)
g6 <- helper("cumhaz")
g <- arrange_ggsurvplots(list(g1, g2, g3, g4, g5, g6), 
                         title="Effect of SNP 17:58358769",
                         ncol=2, nrow=3)
g
```

Krista: The codes below give error: "Error in match.names(clabs, names(xi)) : 
  names do not match previous names"
I wasn't able to figure what was the problem.

```{r All survival}
#survminer::ggforest(cox_fits_list$all, data = scaled_sur)
```

```{r Male survival}
# survminer::ggforest(cox_fits_list$male, data = scaled_sur_male) 
```

```{r Female survival}
# survminer::ggforest(cox_fits_list$female, data = scaled_sur_female)
```

```{r Premenopausal female survival}
# survminer::ggforest(cox_fit_pre_menopausal_female, data = scaled_sur_pre_menopausal_female) 
```

```{r Postmenopausal female survival}
# survminer::ggforest(cox_fit_post_menopausal_female, data = scaled_sur_post_menopausal_female) 
```


### 4.3.3. Effect Sizes

```{r}
# descript2 <- descript %>%
#   mutate(Variable2 = ifelse(Type=="boolean", sprintf("%sTRUE", Variable), Variable))

cox_cis_helper <- function(fit) {
  tidy_cis <- broom::tidy(fit, conf.int = TRUE, exponentiate = TRUE)
  
  cox_cis <- tidy_cis %>%
    rename(low = conf.low, high = conf.high) %>%
    left_join(descript2, by = c(term = "Variable2")) %>%
    filter(term != "(Intercept)") %>%
    mutate(Pretty = ifelse(is.na(Pretty), term, Pretty)) %>%
    mutate(Pretty = as.factor(Pretty))
  
  return(cox_cis)
}

filename <- sprintf("%s/cox_cis.tsv", table_path)
#recompute <- FALSE
if (recompute | !file.exists(filename)) {
  cox_cis <- map_dfr(cox_fits_list, cox_cis_helper, .id = "group")
  write_tsv(cox_cis, file=filename)
} else {
  cox_cis <- read_tsv(filename)
  cat("Loaded precomputed cos_cis.")
}
```

```{r Plotting cox_cis, fig.dim=c(8,12)}

g <- cox_cis %>% 
  mutate(Pretty = fct_rev(Pretty)) %>%
  mutate(Group = factor(group)) %>%
  mutate(hollow_group = factor(ifelse(low <= 1 & high >= 1, NA_character_, as.character(Group)), 
                               levels = levels(Group))) %>%
  ggplot(aes(x = estimate, xmin = low, xmax = high, y = term, # y = Pretty for pretty labs
             color = group, fill = hollow_group)) +
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  stat_stripes(aes(stripe = Pretty), alpha = 0.5, fill = "lightgray") +
  ggstance::geom_linerangeh(position = position_dodge(width = 1), size = 0.2) +
  geom_point(shape = 21, size = 1.5, position = position_dodge(width = 1)) +
  labs(title = "Cox cis", x="Hazard ratio", y="Standardized variables") + 
  #xlim(0.2, 10) +
  scale_colour_manual(values = cohort_colors[mygroups], labels = cohort_names[mygroups]) +
  scale_fill_manual(guide = "none", values = cohort_colors[mygroups], na.value = NA) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  scale_x_log10() +
  scale_y_discrete()

if (save_figs) {
  filename <- sprintf("%s/cox_cis.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 300, units="mm", dpi=300, scale=1.0, device="png")
}

g
```


### 4.3.4. Odds ratios of high genetic risk (normal Cox) (NOT needed for this project)

NOT DONE CAUSE I DON'T HAVE PRS IN THE MODELS! Codes can be found in the
https://github.com/FRCBS/anemia_and_hb_deferral_prediction/blob/5a960498883fcca439d5491aca3a593b3dffea86/src/deferral_logistic_and_cox.Rmd

```{r, include=FALSE}
# compute_total_score <- function(group, data, effect_sizes) {
#   v <- effect_sizes %>% 
#     filter(group==group, str_starts(Variable, "snp_") | str_starts(Variable, "prs_")) %>% 
#     select(Variable, estimate) %>% 
#     mutate(Estimate = log(estimate)) %>%
#     deframe()
#   #total <- dosages %>% rowwise(donor) %>% summarise(total=sum(c_across(everything())))
#   weighted_sum <- data %>% mutate(total = 
#                                               #snp_1_169549811 * v[["snp_1_169549811"]] + 
#                                               snp_6_32618190  * v[["snp_6_32618190"]]  +
#                                               snp_15_45099877 * v[["snp_15_45099877"]] +
#                                               snp_17_58358769 * v[["snp_17_58358769"]])
#   weighted_sum
# }
```

```{r Helper functions, include=FALSE}
# risk_score_distribution <- function(group, data, effect_sizes)  {
#   # Effect sizes of genetic variables
#   v <- effect_sizes %>% 
#     filter(group==group, str_starts(Variable, "snp_") | str_starts(Variable, "prs_")) %>% 
#     select(Variable, estimate) %>% 
#     mutate(Estimate = log(estimate)) %>%
#     deframe()
#   df <- compute_total_score(group, data, effect_sizes)
#   
#   # Compute the percentile to which each donor belongs to
#   df2 <- df %>% 
#     mutate(decile = cut(total, 
#                             breaks=quantile(total, seq(0.0, 1.0, 0.1)), 
#                             labels=1:10,
#                             include.lowest=TRUE)) %>%
#     mutate(across(all_of(genetic_variables), function(x) x*v[[cur_column()]]))
#   df2
# }
# 
# risk_score_histogram <- function(group, data, effect_sizes)  {
#   df2 <- risk_score_distribution(group, data, effect_sizes)
#   my_summarise <- function(df, func) {
#       df %>%
#         group_by(decile) %>%
#         summarise(across(all_of(genetic_variables), func)) %>%
#         pivot_longer(cols = !decile)
#     }
#     L <- list(mean=my_summarise(df2, mean), median=my_summarise(df2, median))
#     df <- bind_rows(L, .id="Method") %>%
#       mutate(name = factor(name, levels=genetic_variables))
#     df
# }
# 
# visualize_risk_score_histogram <- function(df) {
#     g <- df %>%
#       ggplot(aes(x=decile, y=value, fill=name)) +
#       geom_col(position="stack") +
#       GGally::geom_stripped_cols() +
#       facet_grid(~Method) +
#       labs(title=group) +
#       theme(#legend.position="bottom",    
#         panel.grid.major.x = element_blank(),
#         panel.grid.minor.x = element_blank())
#     g
# }
```

```{r, include=FALSE}
# 
# normal_cox_datas <- list(male=scaled_sur_male, female=scaled_sur_female)
# groups <- c("male", "female")
# normal_cox_risk_score_histograms <- map(groups, function(group) risk_score_histogram(group, normal_cox_datas[[group]], cox_cis))
# names(normal_cox_risk_score_histograms) <- groups
# 
# for (group in groups) {
#   g <- visualize_risk_score_histogram(normal_cox_risk_score_histograms[[group]])
#   plot(g)
#   filename <- sprintf("%s/deferral_normal_cox_total_score_histogram_%s.png", fig_path, group)
#   if (save_figs)
#     ggsave(filename=filename, g, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
# }

```

```{r, include=FALSE}
# filename <- sprintf("%s/deferral_normal_cox_genetic_risks.tsv", table_path)
# if (recompute | !file.exists(filename)) {
#   group_names <- c("male", "female")
#   group_names
#   #weighted_sum_samples <- map(group_names, sample_sum_scores)
#   # The below is another version that samples the effect sizes from normal distribution instead of the Bayes samples
#   weighted_sum_samples <- map2(group_names, normal_cox_datas[group_names], sample_sum_scores2, cox_cis, iterations=2000)
#   names(weighted_sum_samples) <- group_names
#   odds_ratio_samples <- map(weighted_sum_samples, apply, 1, get_odds_ratio2)
#   odds_ratio_ci <- map(odds_ratio_samples, quantile, c(0.025, 0.975))
#   normal_cox_genetic_risks <- bind_rows(odds_ratio_ci, .id="group")
#   normal_cox_genetic_risks$mean <- map_dbl(odds_ratio_samples, mean)
#   write_tsv(normal_cox_genetic_risks, file=filename)
# } else {
#   normal_cox_genetic_risks <- read_tsv(filename)
# }
# normal_cox_genetic_risks
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (normal cox male), include=FALSE}
# genetic_scores <-  compute_total_score("male", scaled_sur_male, cox_cis)
# # Which genetic variable combinations are at 1st and 9th deciles?
# indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
# params <- genetic_scores[indices,]
# # Set non-genetic variables to zero
# vars <- setdiff(cox_variables, genetic_variables)
# params[, vars] <- 0
# params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
# params
# #sf <- survfit(cox_fit_male, data=scaled_sur_male)
# g <- survminer::ggsurvplot(survfit(cox_fit_male, newdata=params), 
#                            data=params, risk.table = FALSE, fun=NULL,
#                            legend.title ="Total genetic score quantile",
#                            legend.labs = c(0.1, 0.9))
# g
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (normal cos female), include=FALSE}
# genetic_scores <-  compute_total_score("female", scaled_sur_female, cox_cis)
# # Which genetic variable combinations are at 1st and 9th deciles?
# indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
# params <- genetic_scores[indices,]
# # Set non-genetic variables to zero
# vars <- setdiff(cox_variables, genetic_variables)
# params[, vars] <- 0
# params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
# params
# sf <- survfit(cox_fit_female, data=scaled_sur_female)
# g <- survminer::ggsurvplot(survfit(cox_fit_female, newdata=params), 
#                            data=params, risk.table = FALSE, fun=NULL,
#                            legend.title ="Total genetic score quantile",
#                            legend.labs = c(0.1, 0.9))
# g
```



### 4.3.5. Diagnostics

Jarkko: See [diagnostics](http://www.sthda.com/english/wiki/cox-model-assumptions)

#### Check for proportional hazards assumption

Test the null hypothesis that the proportional hazards assumption holds.

```{r}
#summary(cox_fits_list$pre_menopausal_female)

# table(scaled_sur_pre_menopausal_female$snp_15_45099877, scaled_sur_pre_menopausal_female$surv_status)
# table(scaled_sur_pre_menopausal_female$snp_17_58358769, scaled_sur_pre_menopausal_female$surv_status)
```

pvalue_table() isn't turning to look as it should in the html.

```{r}
extract_ph_stats <- function(fit) { # Get p-values of variables from the fit
  survival::cox.zph(fit)$table %>% as.data.frame() %>% rownames_to_column(var="variable") %>% select(variable, p)
}

res <- map_dfr(cox_fits_list, extract_ph_stats, .id="group") %>% pivot_wider(names_from = group, values_from=p)
#pvalue_table(res)
#print(res)
print.data.frame(res)

#cat(pvalue_table(res))
```

```{r}
#library(webshot2)

# Create a custom color function
custom_color <- function(x) {
  ifelse(x < 0.05, "#D55E00", "#0072B2")
}

# Create a gt table with custom color coding for numeric columns only
gt_table <- res %>%
  mutate(variable = to_pretty_vector(variable, descript)) %>%
  mutate(variable = case_when(variable == "smoking:female" ~ "Smoking:Female",
                              variable == "snp_1_169549811:group" ~ "SNP 1:169549811:Group",
                              variable == "snp_22_37066896:group" ~ "SNP 22:37066896:Group",
                              TRUE ~ variable)) %>%
  gt() %>%
  data_color(
    columns = -variable,
    colors = scales::col_bin(
      bins = c(-Inf, 0.05, Inf),
      palette = c("#D55E00", "#0072B2")
    )
  ) %>%
  tab_header(
    title = "(a) Proportional Hazards Test Results for Cox models",
    subtitle = "P-values for each variable across different groups"
  ) %>%
  tab_footnote(
    footnote = "Orange: p-value < 0.05, Blue: p-value  0.05",
    locations = cells_title(groups = "title")
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_body(columns = everything())
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_column_labels(columns = everything())
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_stub()
  )

# Save the table as a PNG
filename <- sprintf("%s/ph_test_results_cox.png", fig_path)
gtsave(gt_table, filename, vwidth = 300)

# Save the table as a PDF
filename <- sprintf("%s/ph_test_results_cox.pdf", fig_path)
gtsave(gt_table, filename)

# Print the table
print(gt_table)
```


```{r, eval=FALSE}

# # Don't repeat the constant part of labels
# helper <- function(g) {
#   g$labels$title <- str_remove(g$labels$title, "Schoenfeld Individual ")
#   g$labels$y <- str_remove(g$labels$y, "Beta\\(t\\) for ")
#   g
# }
# 
# schoenfeld_residuals <- function(fit, title) {
#   test_ph <- cox.zph(fit)
#   g <- ggcoxzph(test_ph)
#   g <- map(g, helper)   # Remove the repeated texts
#   # I use plot_grid instead of the default plotting method, since
#   # otherwise the combined plot disappears, when zoomed.
#   g2 <- cowplot::plot_grid(plotlist = g)
#   annotate_figure(g2, top = text_grob(paste("Schoenfeld residuals", title, sep=" ")),
#                   left = "Beta(t)")
# }
# schoenfeld_residuals(cox_fits_list$all, "all")
# schoenfeld_residuals(cox_fits_list$male, "male")
# schoenfeld_residuals(cox_fits_list$female, "female")
# schoenfeld_residuals(cox_fits_list$pre_menopausal_female, "premenopausal female")
# schoenfeld_residuals(cox_fits_list$post_menopausal_female, "postmenopausal female")
```

#### Schoenfeld residuals

```{r Schoenfeld residual plots}
# Don't repeat the constant part of labels
helper <- function(g) {
  g$labels$title <- str_remove(g$labels$title, "Schoenfeld Individual ")
  g$labels$y <- str_remove(g$labels$y, "Beta\\(t\\) for ")
  g
}

schoenfeld_residuals <- function(fit, title) {
  test_ph <- cox.zph(fit)
  g <- ggcoxzph(test_ph)
  g <- map(g, helper)   # Remove the repeated texts
  
  # Create a list to store individual plots
  plot_list <- list()
  
  # Loop through each plot and add to the list
  for (i in seq_along(g)) {
    plot_list[[i]] <- g[[i]] + ggtitle(paste("Schoenfeld residuals", title, sep=" "))
  }
  
  # Split the plots into pages with 6 plots per page
  num_plots <- length(plot_list)
  plots_per_page <- 4
  num_pages <- ceiling(num_plots / plots_per_page)
  
  for (page in seq_len(num_pages)) {
    start_idx <- (page - 1) * plots_per_page + 1
    end_idx <- min(page * plots_per_page, num_plots)
    plot_page <- plot_list[start_idx:end_idx]
    
    g2 <- cowplot::plot_grid(plotlist = plot_page, ncol = 2, nrow = 2)
    print(annotate_figure(g2, top = text_grob(paste("Schoenfeld residuals", title, "Page", page, sep=" ")),
                          left = "Beta(t)"))
  }
}

schoenfeld_residuals(cox_fits_list$all, "all")
schoenfeld_residuals(cox_fits_list$male, "male")
schoenfeld_residuals(cox_fits_list$female, "female")
# schoenfeld_residuals(cox_fits_list$pre_menopausal_female, "premenopausal female")
# schoenfeld_residuals(cox_fits_list$post_menopausal_female, "postmenopausal female")

```

Krista: I don't if these look as they should. There are clear patterns in almost all plots.
The snps of course are divided to 0,1,2 dosages where possible.

The continous variables look okay, but the snps not, but this is expected due to the nature of
the varibles. I don't think these work well with the type of variables snps are.

#### Check for outliers

Jarkko:
Its also possible to check outliers by visualizing the deviance residuals. The deviance 
residual is a normalized transform of the martingale residual. These residuals should be 
roughly symmetrically distributed about zero with a standard deviation of 1.

*    Positive values correspond to individuals that died too soon compared to expected survival times.
*    Negative values correspond to individual that lived too long.
*    Very large or small values are outliers, which are poorly predicted by the model.

```{r Deviance residuals - Linear predictions and observarion id plots}
s <- "linear.predictions"
ggcoxdiagnostics(cox_fits_list$all,    type = "deviance", ox.scale = s)
ggcoxdiagnostics(cox_fits_list$male,   type = "deviance", ox.scale = s)
ggcoxdiagnostics(cox_fits_list$female, type = "deviance", ox.scale = s)

# The reason for bipartite cloud can be seen better in the below plots,
# where the OX axis is the observation id. The observations are sorted
# by the event year.
s <- "observation.id"
ggcoxdiagnostics(cox_fits_list$all,    type = "deviance", ox.scale = s, title = "Outliers: All")
ggcoxdiagnostics(cox_fits_list$male,   type = "deviance", ox.scale = s, title = "Outliers: Male")
ggcoxdiagnostics(cox_fits_list$female, type = "deviance", ox.scale = s, title = "Outliers: Female")

```

Let's color the points by event status.

```{r Deviance residuals - Linear predictions with colors for surv_status}
my_residual_plot <- function(fit, data, group_opt) {
  t <- "deviance"
  r <- residuals(fit, type=t)
  data <- data %>% mutate(r = r, 
                          linear_predictors = fit$linear.predictors,
                          cox_status = case_when(cox_status == 0 ~ "Censored", TRUE ~ "Deferral"))
  data %>% ggplot(aes(x=linear_predictors, y=r, color=cox_status)) + 
    geom_hline(yintercept = 0) +
    geom_point() +
    labs(y=t, title = group_opt)
}
m <- my_residual_plot(cox_fits_list$male, scaled_sur_male, "male")
m

f <- my_residual_plot(cox_fits_list$female, scaled_sur_female, "female")
f

a <- my_residual_plot(cox_fits_list$all, scaled_sur, "all")
a
```


```{r}
#summary(cox_fit_all)
```

*THE FOLLOWING DOES NOT WORK!!!*
Krista: If ox.scale = "time" is removed the code works fine, but x-axis is the Observation id.

```{r, eval=FALSE}
# g <- ggcoxdiagnostics(cox_fit_all,
#                  type = "schoenfeld",
#                  #type = "deviance",
#                  ox.scale = "time"
#                  )
# g
```


#### Check for linearity of predictors

Krista: We don't have bmi as a predictor so which one should one check?
blood_volmume is closes to weight and bmi.

Using scaled_sur_male caused 6084 observations deleted due to missingness.
Scaling made many of the blood_volume values to be 0 and log(0) = -Inf.


```{r,eval=FALSE}

# summary(scaled_sur_male %>% drop_na(blood_volume) %>% select(blood_volume))
# summary(tmp_fit)
# summary(scaled_sur_male)


tmp_fit <- survival::coxph(Surv(age, cox_status) ~ blood_volume + log(blood_volume) + sqrt(blood_volume),
                           data = unscaled_sur_male %>% drop_na(blood_volume))
ggcoxfunctional(tmp_fit)

```



## 4.4. Survival with time-dependent covariates

### 4.4.1. Scale data for models with time-dependent covariates

Data created already in the beginning of this .Rmd.

Here is a vignette used as guide to generate the correct survival data for time dependent 
cox analysis: https://cran.r-project.org/web/packages/survival/vignettes/timedep.pdf

```{r Scale for time-dependent Cox model datasets}
scale_helper <- function(df) {
  df %>% mutate(across(where(is.numeric) & !any_of(c("tstart", "tstop", "tdc_status")) & ! starts_with("snp_"),
                       myscale))
}
tdc_scaled_all <- scale_helper(data_tdc2)
tdc_scaled_male <- scale_helper(data_tdc2 %>% filter(female == FALSE))
tdc_scaled_female <- scale_helper(data_tdc2 %>% filter(female == TRUE))

datas_tdc_scaled <- list(tdc_scaled_all, tdc_scaled_male, tdc_scaled_female)
```

### 4.4.2. Fit models

```{r}
# baseline_variables
# tdc_variables
# tdc_model_variables
```

```{r Time-dependent Cox formulas}

baseline_variables <- setdiff(baseline_variables,
                         c("snp_6_21989753", "snp_6_22583313", "snp_6_23835557"))

tdc_formula_all <- as.formula(sprintf("Surv(tstart, tstop, tdc_status) ~ %s", 
                                      paste(c(baseline_variables, tdc_variables), collapse=" + ")))
print(tdc_formula_all)

tdc_formula_male <- as.formula(sprintf("Surv(tstart, tstop, tdc_status) ~ %s", 
                                      paste(setdiff(c(baseline_variables, tdc_variables), c("female", 
                                                                                            "snp_6_68206710", 
                                                                                            "snp_11_5226799"
                                                                                            )),
                                            collapse=" + ")))
print(tdc_formula_male)

tdc_formula_female <- as.formula((sprintf("Surv(tstart, tstop, tdc_status) ~ %s", 
                                      paste(setdiff(c(baseline_variables, tdc_variables), "female"),
                                            collapse=" + "))))
print(tdc_formula_female)

# tdc_formula__pre_menopausal_female <- (sprintf("Surv(tstart, tstop, tdc_status) ~ %s",
#                                       paste(setdiff(c(baseline_variables, tdc_variables), 
#                                                     c("female", "snp_6_22583313")),
#                                             collapse=" + ")))
# print(tdc_formula_pre_menopausal_female)
# 
# tdc_formula_post_menopausal_female <- (sprintf("Surv(tstart, tstop, tdc_status) ~ %s",
#                                       paste(setdiff(c(baseline_variables, tdc_variables), 
#                                                     c("female",
#                                                       "snp_6_21989753", "snp_6_22583313",
#                                                       "snp_6_23835557", "snp_7_75844637",
#                                                       "snp_11_5226799", "snp_15_45099877")),
#                                             collapse=" + ")))
# print(tdc_formula_post_menopausal_female)
```

```{r Fit Cox models with time-dependent variables}
filename <- sprintf("%s/tdc_fits.rds", base)

if(recompute | !file.exists(filename)) {
  tdc_fit_all <- coxph(tdc_formula_all, tdc_scaled_all)
  tdc_fit_male <- coxph(tdc_formula_male, tdc_scaled_male)
  tdc_fit_female <- coxph(tdc_formula_female, tdc_scaled_female)
  
  tdc_fits_list <- list(all=tdc_fit_all, male=tdc_fit_male, female=tdc_fit_female)
  saveRDS(tdc_fits_list, filename)
} else {
  tdc_fits_list <- readRDS(filename)
  cat("Loaded prefitted tdc models.")
}
```

```{r Saving separate tdc fits}
filename <- sprintf("%s/tdc_fit_%s.rds", base, "all")
saveRDS(tdc_fits_list$all, filename)

filename <- sprintf("%s/tdc_fit_%s.rds", base, "male")
saveRDS(tdc_fits_list$male, filename)

filename <- sprintf("%s/tdc_fit_%s.rds", base, "female")
saveRDS(tdc_fits_list$female, filename)
```

### 4.4.3. Effect sizes

```{r Compute time-dependent Cox model effect sizes, fig.dim=c(8,12)}
filename <- sprintf("%s/tdc_cis_train.tsv", table_path)
if (recompute | !file.exists(filename)) {
  tdc_cis <- map_dfr(tdc_fits_list, cox_cis_helper, .id = "group")
  write_tsv(tdc_cis, file=filename)
} else {
  tdc_cis <- read_tsv(filename)
  cat("Loaded precomputed tdc_cis.")
}
```


```{r Plot time-dependent Cox model effect sizes, fig.dim=c(8,12)}
g <- tdc_cis %>% 
  mutate(Pretty = fct_rev(Pretty)) %>%
  mutate(Group = factor(group)) %>%
  mutate(hollow_group = factor(ifelse(low <= 1 & high >= 1, NA_character_, as.character(Group)), 
                               levels = levels(Group))) %>%
  ggplot(aes(x = estimate, xmin = low, xmax = high, y = term, # y = Pretty for pretty labs
             color = group, fill = hollow_group)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  stat_stripes(aes(stripe = Pretty), alpha = 0.5, fill = "lightgray") +
  ggstance::geom_linerangeh(position = position_dodge(width = 1), size = 0.2) +
  geom_point(shape = 21, size = 1.5, position = position_dodge(width = 1)) +
  
  labs(title = "Time-dependent cox model", x="Hazard ratio", y="Standardized variables") + 
  scale_colour_manual(values = cohort_colors[mygroups], labels = cohort_names[mygroups]) +
  scale_fill_manual(guide = "none", values = cohort_colors[mygroups], na.value = NA) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  scale_x_log10() +
  scale_y_discrete() 

if (save_figs) {
  filename <- sprintf("%s/tdc_cis_train.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 300, units="mm", dpi=300, scale=1.0, device="png")
}
g
```

### 4.4.4. Diagnostics

Can we discard the null hypothesis that the proportional hazards assumption holds?

```{r}
res <- map_dfr(tdc_fits_list, extract_ph_stats, .id="model") %>% 
  pivot_wider(names_from = model, values_from=p)
#pvalue_table(res)
#print(res)
print.data.frame(res)
```

```{r}
custom_color <- function(x) {
  ifelse(x < 0.05, "#D55E00", "#0072B2")
}

# Create a gt table with custom color coding for numeric columns only
gt_table <- res %>%
  mutate(variable = to_pretty_vector(variable, descript)) %>%
  mutate(variable = case_when(variable == "smoking:female" ~ "Smoking:Female",
                              variable == "snp_1_169549811:group" ~ "SNP 1:169549811:Group",
                              variable == "snp_22_37066896:group" ~ "SNP 22:37066896:Group",
                              TRUE ~ variable)) %>%
  gt() %>%
  data_color(
    columns = -variable,
    colors = scales::col_bin(
      bins = c(-Inf, 0.05, Inf),
      palette = c("#D55E00", "#0072B2")
    )
  ) %>%
  tab_header(
    title = "(b) Proportional Hazards Test Results for Tdc models",
    subtitle = "P-values for each variable across different groups"
  ) %>%
  tab_footnote(
    footnote = "Orange: p-value < 0.05, Blue: p-value  0.05",
    locations = cells_title(groups = "title")
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_body(columns = everything())
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_column_labels(columns = everything())
  ) %>%
  tab_style(
    style = cell_borders(
      sides = "all",
      color = "black",
      weight = px(2)
    ),
    locations = cells_stub()
  )

# Save the table as a PNG
filename <- sprintf("%s/ph_test_results_tdc.png", fig_path)
gtsave(gt_table, filename, vwidth = 300)

# Save the table as a PDF
filename <- sprintf("%s/ph_test_results_tdc.pdf", fig_path)
gtsave(gt_table, filename)

# Print the table
print(gt_table)
```

```{r Cox and Tdc PH tables combined}
# Combine the two images side by side
img1 <- image_read(sprintf("%s/ph_test_results_cox.png", fig_path))
img2 <- image_read(sprintf("%s/ph_test_results_tdc.png", fig_path))
combined_img <- image_append(c(img1, img2), stack = FALSE)

# Save the combined image
filename <- sprintf("%s/combined_ph_test_tables.png", fig_path)
image_write(combined_img, "combined_ph_test_tables.png")
combined_img <- image_append(c(img1, img2), stack = FALSE)

# Save the combined image
filename <- sprintf("%s/combined_ph_test_tables.png", fig_path)
image_write(combined_img, filename)
```

### 4.4.5. Odds ratios of high genetic risk (TDC Cox) (NOT needed for this project)

```{r, include=FALSE}
# tdc_cox_datas <- list(male=tdc_scaled_male %>% select(donor, all_of(genetic_variables)) %>% distinct(),
#                       female=tdc_scaled_female %>% select(donor_id, all_of(genetic_variables)) %>% distinct())
# groups <- c("male", "female")
# tdc_cox_risk_score_histograms <- map(groups, function(group) risk_score_histogram(group, tdc_cox_datas[[group]], tdc_cis))
# names(tdc_cox_risk_score_histograms) <- groups
# for (group in groups) {
#   g <- visualize_risk_score_histogram(tdc_cox_risk_score_histograms[[group]])
#   plot(g)
#   filename <- sprintf("%s/deferral_tdc_cox_total_score_histogram_%s.png", fig_path, group)
#   if (save_figs)
#     ggsave(filename=filename, g, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
# }

```

```{r Sanity check of the distributions of each genetic variable, include=FALSE}
# tdc_cox_risk_score_distributions <- map(groups, function(group) risk_score_distribution(group, tdc_cox_datas[[group]], tdc_cis))
# names(tdc_cox_risk_score_distributions) <- groups
# helper <- function(df, label) {
#   df2 <- df %>%
#     pivot_longer(cols = all_of(genetic_variables)) 
#   df2 %>%
#     ggplot(aes(value)) +
#     geom_histogram() +
#     geom_vline(data = df2 %>% 
#                  group_by(name, decile) %>% 
#                  summarise(mean=mean(value), median=median(value), .groups = "drop") %>% 
#                  pivot_longer(cols=c("mean", "median"), names_to = "method"),
#                mapping = aes(xintercept=value, color=method),
#                size=0.25) +
#     facet_grid(name ~decile, scales = "free") +
#     labs(title = sprintf("%s n=%i", label, tdc_cox_risk_score_distributions[[str_to_lower(label)]] %>% pull(donor) %>% unique() %>% length))
# }
# g_male <- helper(tdc_cox_risk_score_distributions$male, "Male") + theme_gray(base_size = 7)
# g_female <- helper(tdc_cox_risk_score_distributions$female, "Female") + theme_gray(base_size = 7)
# g_male
# g_female
# ggsave("/tmp/male.png", g_male, width = 180, height=90, units="mm")
# ggsave("/tmp/female.png", g_female, width = 180, height=90, units="mm")
```

```{r Compute confidence intervals for genetic risk odd ratio, include=FALSE}
# filename <- sprintf("%s/deferral_tdc_cox_genetic_risks.tsv", table_path)
# if (recompute | !file.exists(filename)) {
#   group_names <- c("male", "female")
#   group_names
#   #weighted_sum_samples <- map(group_names, sample_sum_scores)
#   # The below is another version that samples the effect sizes from normal distribution instead of the Bayes samples
#   weighted_sum_samples <- map2(group_names, tdc_cox_datas[group_names], sample_sum_scores2, tdc_cis, iterations=2000)
#   names(weighted_sum_samples) <- group_names
#   odds_ratio_samples <- map(weighted_sum_samples, apply, 1, get_odds_ratio2)
#   odds_ratio_ci <- map(odds_ratio_samples, quantile, c(0.025, 0.975))
#   tdc_cox_genetic_risks <- bind_rows(odds_ratio_ci, .id="group")
#   tdc_cox_genetic_risks$mean <- map_dbl(odds_ratio_samples, mean)
#   write_tsv(tdc_cox_genetic_risks, file=filename)
# } else {
#   tdc_cox_genetic_risks <- read_tsv(filename)
# }
# tdc_cox_genetic_risks
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (time-dependent cox male), include=FALSE}
# genetic_scores <-  compute_total_score("male", tdc_scaled_male, tdc_cis)
# # Which genetic variable combinations are at 1st and 9th deciles?
# indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
# params <- genetic_scores[indices,]
# # Set non-genetic variables to zero
# vars <- setdiff(cox_variables, genetic_variables)
# params[, vars] <- 0
# params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
# params
# #sf <- survfit(cox_fit_male, data=scaled_sur_male)
# g <- survminer::ggsurvplot(survfit(tdc_fit_male, newdata=params), 
#                            data=params, risk.table = FALSE, fun=NULL,
#                            legend.title ="Total genetic score quantile",
#                            legend.labs = c(0.1, 0.9))
# g
```

```{r Survival curves for total genetic scores at 1st and 9th deciles (time-dependent cox female), include=FALSE}
# genetic_scores <-  compute_total_score("female", tdc_scaled_female, tdc_cis)
# # Which genetic variable combinations are at 1st and 9th deciles?
# indices <- as.integer(1+(c(0.1, 0.9)*(nrow(genetic_scores)-1)))
# params <- genetic_scores[indices,]
# # Set non-genetic variables to zero
# vars <- setdiff(cox_variables, genetic_variables)
# params[, vars] <- 0
# params$smoking <- factor(FALSE, levels=c(FALSE, TRUE))
# params
# g <- survminer::ggsurvplot(survfit(tdc_fit_female, newdata=params), 
#                            data=params, risk.table = FALSE, fun=NULL,
#                            legend.title ="Total genetic score quantile",
#                            legend.labs = c(0.1, 0.9))
# g
```


## 4.5. Genetic risk using different methods (NOT needed for this project)

```{r, include=FALSE}
# all_genetic_risks <- bind_rows(list(bayes=bayes_genetic_risks, normal_cox=normal_cox_genetic_risks, tdc_cox=tdc_cox_genetic_risks),
#                                .id="method") %>% relocate(mean, .after="group")
# filename <- sprintf("%s/deferral_all_genetic_risks.tsv", table_path)
# write_tsv(all_genetic_risks, file=filename)
# openxlsx::write.xlsx(all_genetic_risks, file = sprintf("%s/deferral_all_genetic_risks.xlsx", table_path), overwrite=TRUE)
# all_genetic_risks
```

```{r, include=FALSE}
# # This is shown in the article for the TDC model
# df1 <- bind_rows(bayes_risk_score_histograms, .id="group")
# df2 <- bind_rows(normal_cox_risk_score_histograms, .id="group")
# df3 <- bind_rows(tdc_cox_risk_score_histograms, .id="group")
# deferral_genetic_risk_histograms <- bind_rows(bayes=df1, normal_cox=df2, tdc_cox=df3, .id="method") %>% rename(stat=Method)
# filename <- sprintf("%s/deferral_genetic_risk_histograms.tsv", table_path)
# write_tsv(deferral_genetic_risk_histograms, file=filename)

```

```{r, include=FALSE}
# helper <- function(df, stat) {
#   df %>%
#     filter(group %in% c("male", "female"), stat=={{stat}}) %>%
#     ggplot(aes(x=decile, y=value, fill=name)) +
#     geom_col(position="stack") +
#     GGally::geom_stripped_cols() +
#     facet_grid(group~method) +
#     lims(y=c(-0.4, 0.8)) +
#     labs(title={{stat}}) +
#     theme(#legend.position="bottom",    
#       panel.grid.major.x = element_blank(),
#       panel.grid.minor.x = element_blank())
# }
# g1 <- helper(deferral_genetic_risk_histograms, "median")
# g2 <- helper(deferral_genetic_risk_histograms, "mean")
# filename1 <- sprintf("%s/deferral_all_total_score_histogram_median.png", fig_path)
# filename2 <- sprintf("%s/deferral_all_total_score_histogram_mean.png", fig_path)
# if (save_figs) {
#   ggsave(filename=filename1, g1, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
#   ggsave(filename=filename2, g2, width = 180,  height=90, units="mm", dpi=300, scale=1.0, device="png")
# }  
# g1
# g2
```




## 4.6. Bayesian survival
### 4.6.1. brms way

```{r Bayesian survival, eval=FALSE}
#cox_fit_male <- survival::coxph(cox_formula, data=sur_male)
# bayesian_cox <- brm(cox_formula_all,                     
#     data = scaled_sur, 
#     family = cox(),
#     file = NULL,
#     control = list(max_treedepth = 15),
#     cores = 1,
#     iter = 500)

```

Above code doesn't work for some reason.

### 4.6.2 rstanarm

Let's try rstanarm package (https://cran.r-project.org/web/packages/rstanarm/index.html) instead.


Instructions for survival in rstanarm: https://arxiv.org/abs/2002.09633


Survival models in rstanarm are still experimental and the feature is not included in the cran version. Install
it manually as described below.

```
git clone -b feature/survival https://github.com/stan-dev/rstanarm.git
R -e 'roxygen2::roxygenize("rstanarm"); devtools::install("rstanarm", build_vignettes = FALSE)'
```

KRISTA: the above manual installation didn't work for me. I used the instructions on the github page (https://github.com/stan-dev/rstanarm) 
to get the access to the survival models. I used the code below to install the right repositories.

```
install.packages("rstanarm", repos = c("https://stan-dev.r-universe.dev", getOption("repos")))
```

The following models are not Cox models, but parameterized (M-splines) survival models with time-dependent
covariates.

```{r}
# library(rstanarm)
```

```{r}
# rstanarm_variables <- c("blood_volume",
#                         "previous_Hb",
#                         "smoking",
#                         snp_descript$Variable,
#                         "female")
# 
# # Time-independent variables
# tdc_variables <- c("previous_Hb")  # time-dependent covariates
# 
# baseline_variables <- setdiff(rstanarm_variables, tdc_variables)
# 
# rstanarm_tdc_formula_all <- as.formula(sprintf("Surv(tstart, tstop, tdc_status) ~ %s",
#                                       paste(c(baseline_variables, tdc_variables), collapse=" + ")))
# rstanarm_tdc_formula_male <- as.formula(sprintf("Surv(tstart, tstop, tdc_status) ~ %s",
#                                       paste(setdiff(c(baseline_variables, tdc_variables), 
#                                                     c("female",
#                                                       "snp_6_21989753",
#                                                       "snp_6_22583313", "snp_7_75844637",
#                                                       "snp_22_29795932")),
#                                             collapse=" + ")))
# 
# rstanarm_tdc_formula_female <- as.formula(sprintf("Surv(tstart, tstop, tdc_status) ~ %s",
#                                       paste(setdiff(c(baseline_variables, tdc_variables), "female"),
#                                             collapse=" + ")))
# rstanarm_tdc_formula_all
# rstanarm_tdc_formula_male
# rstanarm_tdc_formula_female
# 
# rstanarm_tdc_formulas <- list(rstanarm_tdc_formula_all, rstanarm_tdc_formula_male, rstanarm_tdc_formula_female)
```


```{r Fit parameterized survival models with time-dependent variables in rstanarm 1, eval=FALSE}
#tdc_fit_all <- coxph(tdc_formula_all, tdc_scaled_all)
#tdc_fit_male <- coxph(tdc_formula_male, tdc_scaled_male)
#tdc_fit_female <- coxph(tdc_formula_female, tdc_scaled_female)
#tdc_fit_list <- list(all=tdc_fit_all, male=tdc_fit_male, female=tdc_fit_female)

# rstanarm_tdc_fit_all <- stan_surv(
#   formula = rstanarm_tdc_formula_all,
#   data = tdc_scaled_all,
#   chains = 4,
#   cores = 4,
#   seed = 10,
#   iter = 100)


# filename <- sprintf("%s/rstanarm_tdc_fits_all.rds", base)
# # saveRDS(rstanarm_tdc_fit_all, filename)
# 
# rstanarm_tdc_fit_all <- readRDS(filename)
```

HOX! Fitting just the all group took around 6 hours with 4 cores while I was doing
nothing on my computer! The first chain from 70/100 forward took 4+ hours when the 
other three chains were ready latest after ca. 2 hours.

```{r Fit rstanarm for groups, eval=FALSE}
# fit_rstanarm_helper <- function(group, data, formula) {
#   filename <- sprintf("%s/rstanarm_tdc_fit_%s.rds", base, group)
#   
#   if (recompute_rstanarm | !file.exists(filename)) { 
#     cat(sprintf("Fitting rstanarm survival model with time-dependent variables for group %s\n", group))
#     rstanarm_tdc_fit <- stan_surv(
#                           formula,
#                           data = data,
#                           chains = 4,
#                           cores = 4,
#                           iter = 100
#     )
#     saveRDS(rstanarm_tdc_fit, filename)
#   } else {
#     cat(sprintf("Loading prefitted rstanarm survival model with time-dependent variables on group %s\n", group))
#     rstanarm_tdc_fit <- readRDS(filename)
#   }
#   return(tibble(group=group, fit=list(rstanarm_tdc_fit)))
# }
# 
# 
# rstanarm_tdc_input <- tibble(group=names(cohort_colors),
#                          data=datas_tdc_scaled,
#                          formula=rstanarm_tdc_formulas)
# rstanarm_tdc_fits <- pmap_dfr(rstanarm_tdc_input, fit_rstanarm_helper)
# rstanarm_tdc_fits_list <- deframe(rstanarm_tdc_fits)
```


```{r Printing and plotting the summaries of rtsanarm models, eval=FALSE}

# for(fit in rstanarm_tdc_fits_list) {
#   print(fit)
#   summary(fit)
#   plot(fit)
# }
# 
# print(rstanarm_tdc_fit_all)
# summary(rstanarm_tdc_fit_all)
# plot(rstanarm_tdc_fit_all)
```

```{r, eval=FALSE}
# I doesn't seem to be possible to run this.
#     Error in ps_check(rstanarm_tdc_fit_all) :
#     'ps_check' cannot currently be used on models with delayed entry.
#ps_check(rstanarm_tdc_fit_all)
```

```{r Computing rstanarm cis, eval=FALSE}
# get_rstanarm_cis <- function(fit) {
#   df <- summary(fit, probs=c(0.025, 0.975), pars="beta") %>% as_tibble(rownames="Variable")
#   df <- df %>% 
#     filter(!str_detect(Variable, "^m-splines")) %>%
#     rename(Estimate=mean, low = `2.5%`, high = `97.5%`) %>%
#     mutate(across(c(Estimate, low, high), exp)) %>%
#     left_join(descript2, by=c(Variable="Variable2")) %>%
#     mutate(Pretty = coalesce(Pretty, Variable)) %>%
#     mutate(Pretty = fct_relevel(Pretty, function(v) str_sort(v, numeric = TRUE))) %>%
#     arrange(Pretty) %>%
#     relocate(Pretty, Variable, Estimate, low, high)
#   df
# }
# rstanarm_all_cis <- get_rstanarm_cis(rstanarm_tdc_fit_all)
```

```{r Plot rstanarm cis, eval=FALSE}
# rstanarm_all_cis %>% 
#   mutate(Group = "all") %>%
#   mutate(across(c(Pretty, Group), fct_rev)) %>%
#   ggplot(aes(x=Estimate, xmin=low, xmax=high, y=Variable, color=Group)) +  # y= Pretty!
#   geom_vline(aes(xintercept=1), color="gray", size=1) +
#   geom_stripes(rstanarm_all_cis, Pretty) +
#   ggstance::geom_pointrangeh(position=position_dodge(width=1)) + 
#   labs(x="Hazard ratio", y="Standardized variables") + 
#   #xlim(0.2, 10) +
#   #scale_x_log10(limits=mylimits) +
#   scale_x_log10() + 
#   scale_y_discrete() + 
#   scale_colour_manual(values=cohort_colors) +
#   labs(title="Bayesian proportional hazards model all")
```

https://mc-stan.org/rstanarm/reference/plot.stanreg.html

"The plot method for stanreg-objects provides a convenient interface to the MCMC module in the bayesplot package for 
plotting MCMC draws and diagnostics."

```{r Plot, eval=FALSE}

# this is a plot function from the rstanarm package used 
# plot(rstanarm_tdc_fit_all, "areas", #regex_pars = "period",
#      prob = 0.5, 
#      prob_outer = 1.0)
```

# 5. Plotting all the effect sizes next to each other

To be able to compare different modelling methods we want to see the effect sizes
next to each other.

Creating plot which includes effect sizes fro snps from all the five methods 
(freq, freq_int, bayes, cox and tdc) next to each other.

```{r Loading cis lists}
freq_cis_groups <- read_tsv(sprintf("%s/freq_groups_cis.tsv", table_path))
freq_int_cis_groups <- read_tsv(sprintf("%s/freq_int_groups_cis.tsv", table_path))
bayes_cis <- read_tsv(sprintf("%s/bayes_cis.tsv", table_path))
spline_cis <- read_tsv(sprintf("%s/spline_cis.tsv", table_path))
cox_cis <- read_tsv(sprintf("%s/cox_cis.tsv", table_path))
tdc_cis <- read_tsv(sprintf("%s/tdc_cis_train.tsv", table_path))
```


```{r Preparation for plots}
groups <- c("all", "male", "female")

#mymodels_legend <- c("freq","bayes_spline", "freq_int", "cox", "bayes", "tdc")
mymodels <- c("LogR", "LogRInt", "BayesLogR", "BayesLogRSpline", "Cox", "Tdc")

model_names <- c(
  LogR = "LogR",
  LogRInt = "LogRInt",
  BayesLogR = "BayesLogR",
  BayesLogRSpline = "BayesLogRSpline",
  Cox = "Cox",
  Tdc = "Tdc"
)

cis_values_list <- list(
  LogR = freq_cis_groups,
  LogRInt = freq_int_cis_groups,
  BayesLogR = bayes_cis,
  BayesLogRSpline = spline_cis,
  Cox = cox_cis,
  Tdc = tdc_cis)

# model names for plot titles
model_titles = c(
  LogR = "Logistic regression",
  LogRInt = "Logistic regression with interactions",
  BayesLogR = "Bayesian logistic regression with interactions",
  BayesLogRSpline = "Bayesian logR, splines for age, blood_volume, days_to_previous_fb",
  Cox = "Cox proportional hazard model",
  Tcd = "Cox with time-dependent variable for previous_Hb"
)

model_colors <- c(
  LogR = "#66A61E",
  LogRInt = "#7570B3",
  BayesLogR = "#D95F02",
  BayesLogRSpline = "#1B9E77",
  Cox = "#E6AB02",
  Tdc = "#E7298A"
)

  # freq = "#7FC97F",
  # freq_int = "#BEAED4",
  # bayes = "#FDC086",
  # spline = "#FFFF99",
  # cox = "#386CB0",
  # tdc = "#F0027F"

# model_lines <- c(
#   freq = "solid",
#   freq_int = "longdash",
#   bayes = "dashed",
#   bayes_spline = "twodash",
#   cox = "dotted",
#   tdc = "dotdash"
# )

x_labs <- c(
  LogR = "Odds ratio",
  LogRInt = "Odds ratio", 
  BayesLogR = "Odds ratio", 
  BayesLogRSpline = "Odds ratio", 
  Cox = "Hazard ratio", 
  Tdc = "Hazard ratio")
```

```{r Plotting snp effect sizes from multiple methods}
# Plot only snp variables
# plot_list <- list()
# i <- 1
# 
# for (i in 1:length(cis_values_list)) {
#   
#   g <- cis_values_list[[i]] %>%
#     mutate(Pretty = fct_rev(Pretty)) %>%
#     mutate(group = factor(group)) %>%
#     mutate(hollow_group = factor(ifelse(low <= 1 & high >= 1, NA_character_, as.character(group)), 
#                                  levels = levels(group))) %>%
#     filter(grepl("^snp_", term)) %>% # only the snp variables
#     ggplot(aes(x = estimate, xmin = low, xmax = high, y = term, # y = Pretty for pretty labs
#                color = group, fill = hollow_group)) +
#     geom_vline(aes(xintercept=1), color="gray", size=1) +
#     stat_stripes(aes(stripe = Pretty), alpha = 0.5, fill = "lightgray") +
#     ggstance::geom_linerangeh(position = position_dodge(width = 1), size = 0.2) +
#     geom_point(shape = 21, size = 1.5, position = position_dodge(width = 1)) +
#     scale_colour_manual(values = cohort_colors[mygroups], labels = cohort_names[mygroups]) +
#     guides(color = guide_legend(override.aes = list(shape = 16))) +
#     labs(title = model_names[i], x=x_labs[i], y="Standardized variables") + 
#     scale_fill_manual(guide = "none", values = cohort_colors[mygroups], na.value = NA) +
#     scale_x_log10() +
#     scale_y_discrete()
#   
#   # removing leged box from all but last plot
#   if (i < length(cis_values_list)) {
#     g <- g + theme(legend.position = "none")
#   }
#   
#   plot_list[[i]] <- g
#   i <- i+1
# }
# 
# # combined_g <- grid.arrange(grobs = plot_list, ncol = 6) 
# 
# if (save_figs) {
#   filename <- sprintf("%s/all_model_cis_with_legend.png", fig_path)
#   ggsave(filename=filename,  plot=grid.arrange(grobs = plot_list, ncol = 6), width = 900,  height = 300, units="mm", dpi=300, scale=1.0, device="png")
# }
# combined_g

```

```{r}
# Add column model to all the dataframes
freq_cis_groups$model <- "LogR"
freq_int_cis_groups$model <- "LogRInt"
bayes_cis$model <- "BayesLogR"
spline_cis$model <- "BayesLogRSpline"
cox_cis$model <- "Cox"
tdc_cis$model <- "Tdc"

combined_cis <-
  bind_rows(freq_cis_groups, spline_cis, freq_int_cis_groups, cox_cis,
            bayes_cis, tdc_cis) %>%
  mutate(Pretty = case_when(
    Pretty == "smokingTRUE:femaleTRUE" ~ "Smoking:Female",
    Pretty == "snp_1_169549811:grouppost_menopausal_female" ~ "SNP 1:169549811:Postmenopausal Female",
    Pretty == "snp_1_169549811:grouppre_menopausal_female" ~ "SNP 1:169549811:Premenopausal Female",
    Pretty == "snp_22_37066896:grouppost_menopausal_female" ~ "SNP 22:37066896:Postmenopausal female",
    Pretty == "snp_22_37066896:grouppre_menopausal_female" ~ "SNP 22:37066896:Premenopausal female",
    TRUE ~ Pretty))

groupped_tables <- combined_cis %>%
  group_split(group) %>%
  set_names(c("all", "female", "male"))

#groupped_tables
```

```{r Effect sizes for all models in one - all, fig.dim=c(8,12)}

g <- groupped_tables$all %>% 
  mutate(Pretty = fct_rev(Pretty)) %>%
  mutate(Model = factor(model, levels = mymodels)) %>%
  mutate(hollow_model = factor(ifelse(low <= 1 & high >= 1, NA_character_, as.character(Model)), 
                               levels = mymodels)) %>%
  mutate(across(c(Model, hollow_model), fct_rev)) %>% # this turns the values the same way as the legend
  ggplot(aes(x = estimate, xmin = low, xmax = high, y = term, # y = Pretty for pretty labs
             color = Model, 
             fill = hollow_model)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  stat_stripes(aes(stripe = term), alpha = 0.5, fill = "lightgray") +
  ggstance::geom_linerangeh(position = position_dodge(width = 1), size = 0.2) +
  geom_point(shape = 21, size = 1.5, position = position_dodge(width = 1)) +
  labs(title = "Effect sizes for group - all", x="Odds ratio/Hazard ratio", y="Standardized variables") + 
  scale_colour_manual(values = model_colors, labels = model_names, breaks = mymodels) +
  scale_fill_manual(guide = "none", values = model_colors, na.value = NA) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  scale_x_log10() +
  scale_y_discrete() 

if (save_figs) {
  filename <- sprintf("%s/combined_effect_sizes_all.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 210,  height = 297, units="mm", dpi=350, scale=1.0, device="png")
}
g
```

```{r Effect sizes for all models in one - male, fig.dim=c(8,12)}

g <- groupped_tables$male %>% 
  mutate(Pretty = fct_rev(Pretty)) %>%
  mutate(Model = factor(model, levels = mymodels)) %>%
  mutate(hollow_model = factor(ifelse(low <= 1 & high >= 1, NA_character_, as.character(Model)), 
                               levels = mymodels)) %>%
  mutate(across(c(Model, hollow_model), fct_rev)) %>% # this turns the values the same way as the legend
  ggplot(aes(x = estimate, xmin = low, xmax = high, y = term, # y = Pretty for pretty labs
             color = Model, 
             fill = hollow_model)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  stat_stripes(aes(stripe = Pretty), alpha = 0.5, fill = "lightgray") +
  ggstance::geom_linerangeh(position = position_dodge(width = 1), size = 0.2) +
  geom_point(shape = 21, size = 1.5, position = position_dodge(width = 1)) +
  labs(title = "Effect sizes for group - male", x="Odds ratio/Hazard ratio", y="Standardized variables") + 
  scale_colour_manual(values = model_colors, labels = model_names, breaks = mymodels) +
  scale_fill_manual(guide = "none", values = model_colors, na.value = NA) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  scale_x_log10() +
  scale_y_discrete() 

if (save_figs) {
  filename <- sprintf("%s/combined_effect_sizes_male.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 350, units="mm", dpi=300, scale=1.0, device="png")
}
g

```

```{r Effect sizes for all models in one - female, fig.dim=c(8,12)}

g <- groupped_tables$female %>% 
  mutate(Pretty = fct_rev(Pretty)) %>%
  mutate(Model = factor(model, levels = mymodels)) %>%
  mutate(hollow_model = factor(ifelse(low <= 1 & high >= 1, NA_character_, as.character(Model)), 
                               levels = mymodels)) %>%
  mutate(across(c(Model, hollow_model), fct_rev)) %>% # this turns the values the same way as the legend
  ggplot(aes(x = estimate, xmin = low, xmax = high, y = term, # y = Pretty for pretty labs
             color = Model, 
             fill = hollow_model)) + 
  geom_vline(aes(xintercept=1), color="gray", size=1) +
  stat_stripes(aes(stripe = Pretty), alpha = 0.5, fill = "lightgray") +
  ggstance::geom_linerangeh(position = position_dodge(width = 1), size = 0.2) +
  geom_point(shape = 21, size = 1.5, position = position_dodge(width = 1)) +
  labs(title = "Effect sizes for group - female", x="Odds ratio/Hazard ratio", y="Standardized variables") + 
  scale_colour_manual(values = model_colors, labels = model_names, breaks = mymodels) +
  scale_fill_manual(guide = "none", values = model_colors, na.value = NA) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  scale_x_log10() +
  scale_y_discrete() 

if (save_figs) {
  filename <- sprintf("%s/combined_effect_sizes_female.png", fig_path)
  ggsave(filename=filename,  plot=g, width = 180,  height = 350, units="mm", dpi=300, scale=1.0, device="png")
}
g
```


## Separate plots for non genomic and genomic variables

We want to have two plots for all groups (all, female, male):
1) non genomic variables
2) Only significant genomic variables

```{r New descripts}
non_genomic_variables <- c("age", "blood_volume", "days_to_previous_fb",
                          "femaleTRUE", "previous_Hb", "recent_deferrals",
                          "recent_donations", "smokingTRUE", "smokingTRUE:femaleTRUE",
                          "warm_seasonTRUE", "year")

genomic_variables_1 <- c("snp_1_113834946", "snp_1_169549811",
                         "snp_1_169549811:grouppre_menopausal_female",
                         "snp_1_169549811:grouppost_menopausal_female",
                          "snp_4_25970243", "snp_6_25857692", "snp_6_32617727", "snp_6_32658525", 
                          "snp_6_68206710", "snp_7_75844637", "snp_8_10785723", "snp_8_23520397", 
                          "snp_8_75503352")

genomic_variables_2 <- c("snp_9_133271182", "snp_10_63174788", "snp_11_5226799", "snp_12_6030341",
                         "snp_14_33938877", "snp_15_45099877", "snp_17_58358769", "snp_20_35186730",
                         "snp_22_29795932", "snp_22_37066896", "snp_22_37066896:grouppost_menopausal_female",
                         "snp_22_37066896:grouppre_menopausal_female")
```

```{r Combined effect sizeds: non-genomic variables}

g <- combined_cis %>%
  filter(term %in% non_genomic_variables) %>%
  mutate(Pretty = fct_relevel(Pretty, function(levels) str_sort(levels, numeric=TRUE))) %>%
  filter(group %in% c("all", "male", "female")) %>%
  mutate(group = factor(group, levels=c("all", "male", "female"))) %>%
  mutate(model = factor(model, levels = mymodels)) %>%  # Set factor levels for model
  mutate(across(c(model, Pretty), fct_rev)) %>%
  mutate(hollow_model=factor(if_else(low<=1 & high>=1, NA_character_, as.character(model)),
                             levels=levels(model))) %>%
  ggplot(aes(x=estimate, xmin=low, xmax=high, y=Pretty, # y=Pretty for pretty labs
             color=model, fill=hollow_model)) + 
  geom_vline(aes(xintercept=1), color="gray", 
             #size=1
             linewidth=1
             ) +
  geom_stripes(freq_int_cis_groups %>% filter(term %in% non_genomic_variables), Pretty) +
  ggstance::geom_linerangeh(position=position_dodge(width=1), 
                            size=0.2
                            #linewidth=0.2
                            ) + 
  geom_point(#aes(), 
             #fill=NA, 
             shape=21,
             size=1.5,
             position=position_dodge(width=1)) +
  labs(#title = "Combined effect sizes: non-genomic", 
       x="Odds ratio/Hazards ratio", y="Standardized variables") + 
  scale_colour_manual(values = model_colors, labels = model_names, breaks = mymodels) +
  scale_fill_manual(guide = "none", values = model_colors, na.value = NA) +
  facet_wrap(~group) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  #coord_cartesian(xlim = c(0.0001, 12)) +
  scale_x_log10() +
  scale_y_discrete() + # This is important. Solves the problem with position_dodge2 
                       # and the order of rect and pointrange geoms!!!
                       # Otherwise following error results: Error: Discrete value supplied to continuous scale
  theme(legend.position="bottom",
        legend.direction = "horizontal",
        plot.title = element_text(face="bold"),
        plot.subtitle = element_text(face="bold"))

if (save_figs) {
  #pdf
  # filename <- sprintf("%s/combined_effect_sizes_non_genomic.pdf", fig_path)
  # ggsave(filename=filename, plot=g, width = 300,  height=300, units="mm", dpi=300, scale=1.0, device="pdf")
  
  #png
  filename <- sprintf("%s/combined_effect_sizes_non_genomic.png", fig_path)
  ggsave(filename=filename, plot=g, width = 210,  height=250, units="mm", dpi=350, device="png")
}

g
```

```{r Combined effect sizes: genomic variables 1}
g <- combined_cis %>%
  filter(term %in% genomic_variables_1) %>%
  mutate(Pretty = fct_relevel(Pretty, function(levels) str_sort(levels, numeric=TRUE))) %>%
  filter(group %in% c("all", "male", "female")) %>%
  mutate(group = factor(group, levels=c("all", "male", "female"))) %>%
  mutate(model = factor(model, levels = mymodels)) %>% 
  mutate(across(c(model, Pretty), fct_rev)) %>%
  mutate(hollow_model=factor(if_else(low<=1 & high>=1, NA_character_, as.character(model)),
                             levels=levels(model))) %>%
  ggplot(aes(x=estimate, xmin=low, xmax=high, y=Pretty, # y=Pretty for pretty labs
             color=model, fill=hollow_model)) + 
  geom_vline(aes(xintercept=1), color="gray", 
             #size=1
             linewidth=1
             ) +
  geom_stripes(freq_int_cis_groups %>% filter(term %in% genomic_variables_1), Pretty) +
  ggstance::geom_linerangeh(position=position_dodge(width=1), 
                            size=0.2
                            #linewidth=0.2
                            ) + 
  geom_point(#aes(), 
             #fill=NA, 
             shape=21,
             size=1.5,
             position=position_dodge(width=1)) +
  labs(#title = "Combined effect sizes: genomic", 
       x="Odds ratio/Hazards ratio", y="Standardized variables") + 
  scale_colour_manual(values = model_colors, labels = model_names, breaks = mymodels) +
  scale_fill_manual(guide = "none", values = model_colors, na.value = NA) +
  facet_wrap(~group) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  #coord_cartesian(xlim = c(0.0001, 12)) +
  scale_x_log10() +
  scale_y_discrete() + # This is important. Solves the problem with position_dodge2 
                       # and the order of rect and pointrange geoms!!!
                       # Otherwise following error results: Error: Discrete value supplied to continuous scale
  theme(legend.position="bottom",
        legend.direction = "horizontal",
        plot.title = element_text(face="bold"),
        plot.subtitle = element_text(face="bold"))

if (save_figs) {
  #pdf
  # filename <- sprintf("%s/combined_effect_sizes_genomic.pdf", fig_path)
  # ggsave(filename=filename, plot=g, width = 300,  height=350, units="mm", dpi=300, scale=1.0, device="pdf")
  
  #png
  filename <- sprintf("%s/combined_effect_sizes_genomic_1.png", fig_path)
  ggsave(filename=filename, plot=g, width = 210,  height=250, units="mm", dpi=350, device="png")
}

g
```


```{r Combined effect sizes: genomic variables 2}
g <- combined_cis %>%
  filter(term %in% genomic_variables_2) %>%
  mutate(Pretty = fct_relevel(Pretty, function(levels) str_sort(levels, numeric=TRUE))) %>%
  filter(group %in% c("all", "male", "female")) %>%
  mutate(group = factor(group, levels=c("all", "male", "female"))) %>%
  mutate(model = factor(model, levels = mymodels)) %>% 
  mutate(across(c(model, Pretty), fct_rev)) %>%
  mutate(hollow_model=factor(if_else(low<=1 & high>=1, NA_character_, as.character(model)),
                             levels=levels(model))) %>%
  ggplot(aes(x=estimate, xmin=low, xmax=high, y=Pretty, # y=Pretty for pretty labs
             color=model, fill=hollow_model)) + 
  geom_vline(aes(xintercept=1), color="gray", 
             #size=1
             linewidth=1
             ) +
  geom_stripes(freq_int_cis_groups %>% filter(term %in% genomic_variables_2), Pretty) +
  ggstance::geom_linerangeh(position=position_dodge(width=1), 
                            size=0.2
                            #linewidth=0.2
                            ) + 
  geom_point(#aes(), 
             #fill=NA, 
             shape=21,
             size=1.5,
             position=position_dodge(width=1)) +
  labs(#title = "Combined effect sizes: genomic", 
       x="Odds ratio/Hazards ratio", y="Standardized variables") + 
  scale_colour_manual(values = model_colors, labels = model_names, breaks = mymodels) +
  scale_fill_manual(guide = "none", values = model_colors, na.value = NA) +
  facet_wrap(~group) +
  guides(color = guide_legend(override.aes = list(shape = 16))) +
  #coord_cartesian(xlim = c(0.0001, 12)) +
  scale_x_log10() +
  scale_y_discrete() + # This is important. Solves the problem with position_dodge2 
                       # and the order of rect and pointrange geoms!!!
                       # Otherwise following error results: Error: Discrete value supplied to continuous scale
  theme(legend.position="bottom",
        legend.direction = "horizontal",
        plot.title = element_text(face="bold"),
        plot.subtitle = element_text(face="bold"))

if (save_figs) {
  #pdf
  # filename <- sprintf("%s/combined_effect_sizes_genomic.pdf", fig_path)
  # ggsave(filename=filename, plot=g, width = 300,  height=350, units="mm", dpi=300, scale=1.0, device="pdf")
  
  #png
  filename <- sprintf("%s/combined_effect_sizes_genomic_2.png", fig_path)
  ggsave(filename=filename, plot=g, width = 210,  height=250, units="mm", dpi=350, device="png")
}

g
```